// Auto Gen

#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "pesapi.h"
#include "TDataTrans.h"
#include "XLuaValueType.h"

namespace xlua
{

// System.Object ChangeType(System.Object, System.TypeCode) declare in System.Convert
bool w_OOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OOi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object ChangeType(System.Object, System.TypeCode, System.IFormatProvider) declare in System.Convert
bool w_OOi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OOi4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object ChangeType(System.Object, System.Type) declare in System.Convert
bool w_OOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OOo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object ChangeType(System.Object, System.Type, System.IFormatProvider) declare in System.Convert
bool w_OOoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OOoo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object CallTemplateMethod(System.Object, System.String, System.Type, System.Object[]) declare in LuaCallCSharpInteraction
bool w_OOsoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OOsoo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object ToObject(System.Type, System.Object) declare in System.Enum
bool w_OoO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OoO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object GetEquipPartTipsData(stShowEquipmentInfo, EquipRecommendRet ByRef, Boolean, Boolean) declare in Assets.Scripts.GameLogic.EquipUtil
bool w_OoPS_u4o_bDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OoPS_u4o_bDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             
    // LuaValToCSVal Pstruct
    S_u4o_* p1 = DataTransfer::GetPointer<S_u4o_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
         // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_u4o_* p2, bool p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object ToObject(System.Type, SByte) declare in System.Enum
bool w_Ooi1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int8_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object ToObject(System.Type, Int16) declare in System.Enum
bool w_Ooi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int16_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object ToObject(System.Type, Int32) declare in System.Enum
bool w_Ooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object ToObject(System.Type, Int64) declare in System.Enum
bool w_Ooi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ooi8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object Parse(System.Type, System.String) declare in System.Enum
bool w_Oos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oos");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object Parse(System.Type, System.String, Boolean) declare in System.Enum
bool w_Oosb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oosb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object ToObject(System.Type, Byte) declare in System.Enum
bool w_Oou1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oou1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint8_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, uint8_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object ToObject(System.Type, UInt16) declare in System.Enum
bool w_Oou2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oou2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, uint16_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object ToObject(System.Type, UInt32) declare in System.Enum
bool w_Oou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oou4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object ToObject(System.Type, UInt64) declare in System.Enum
bool w_Oou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oou8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, uint64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object logError(System.String) declare in LeanTween
bool w_Os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Os");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object get_Parent_From_Lua() declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_Ot(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Ot");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef Il2CppObject* (*FuncToCall)(void*,const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object GetValue(System.Object) declare in System.Reflection.PropertyInfo
bool w_OtO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object GetValue(System.Object, System.Object[]) declare in System.Reflection.PropertyInfo
bool w_OtOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtOo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object GetValueDirect(TypedReference) declare in System.Reflection.FieldInfo
bool w_OtS_S_p_pp_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtS_S_p_pp_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_pp_* pp0 = DataTransfer::GetPointer<S_S_p_pp_>(apis, env, _sv0);
    S_S_p_pp_ p0 = pp0 ? *pp0 : S_S_p_pp_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_S_p_pp_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object GetValue(Int32[]) declare in System.Array
bool w_OtVi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtVi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        if(lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
     
    // LuaValToCSVal primitive params
    Il2CppArray* p0 = Params<int32_t>::PackPrimitive(apis, env, info, TIp0, lua_args_len, 0);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppArray* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object GetValue(Int64[]) declare in System.Array
bool w_OtVi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtVi8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        if(lua_args_len > 0 && !converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
     
    // LuaValToCSVal primitive params
    Il2CppArray* p0 = Params<int64_t>::PackPrimitive(apis, env, info, TIp0, lua_args_len, 0);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppArray* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object GetValue(Int32) declare in System.Array
bool w_Oti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object GetValue(Int32, Int32) declare in System.Array
bool w_Oti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object GetValue(Int32, Int32, Int32) declare in System.Array
bool w_Oti4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object GetValue(Int64) declare in System.Array
bool w_Oti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int64_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object GetValue(Int64, Int64) declare in System.Array
bool w_Oti8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti8i8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int64_t p1, int64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object GetValue(Int64, Int64, Int64) declare in System.Array
bool w_Oti8i8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Oti8i8i8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int64_t p1, int64_t p2, int64_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object InvokeLuaMethod(System.String, System.Object[]) declare in Assets.Scripts.Framework.UI.UILuaPrefabClass
bool w_OtsVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_OtsVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[]) declare in System.Type
bool w_Otsi4oOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otsi4oOo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Object InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[], System.Globalization.CultureInfo) declare in System.Type
bool w_Otsi4oOoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Otsi4oOoo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, Il2CppObject* p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// DisplayInfoData* GetDisplayData_Blocked() declare in SGW
bool w_PS_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_PS_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_* (*FuncToCall)(const void* method);
    struct S_u4S_i4i4i4_S_r4r4r4_i4S_r4r4r4r4_u4u1_* ret = ((FuncToCall)methodPointer)(  method);
	int r = apis->boxing(env, apis->native_object_to_value(env, TIret, ret, false));
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte* OSG_PushImmediateBuffer(Int32) declare in SGamePInvoke
bool w_Pu1i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Pu1i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef uint8_t* (*FuncToCall)(int32_t p1, const void* method);
    uint8_t* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<std::reference_wrapper<uint8_t>>::toScript(apis, env, *ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte* OSG_PushInputBuffer(Int32, UInt16, UInt16) declare in SGamePInvoke
bool w_Pu1i4u2u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_Pu1i4u2u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(apis, env, _sv2);
        
    typedef uint8_t* (*FuncToCall)(int32_t p1, uint16_t p2, uint16_t p3, const void* method);
    uint8_t* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<std::reference_wrapper<uint8_t>>::toScript(apis, env, *ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// RayCastResult DoRaycast(UnityEngine.Collider, UnityEngine.Ray, Single) declare in LuaCallCSharpInteraction
bool w_S_S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_b_oS_S_r4r4r4_S_r4r4r4__r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_b_oS_S_r4r4r4_S_r4r4r4__r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef struct S_S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_b_ (*FuncToCall)(Il2CppObject* p1, struct S_S_r4r4r4_S_r4r4r4__ p2, float p3, const void* method);
    struct S_S_S_r4r4r4_S_r4r4r4_u4r4S_r4r4_i4_b_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Yarp.GfxCullingParameters Create(UnityEngine.Camera) declare in Yarp.GfxCullingParameters
bool w_S_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4__o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef struct S_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4__ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4__ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.ReadOnlySpan`1[System.Char] GetDirectoryName(System.ReadOnlySpan`1[System.Char]) declare in System.IO.Path
bool w_S_S_p_i4_S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_S_S_p_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
        
    typedef struct S_S_p_i4_ (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.ReadOnlySpan`1[System.Char] op_Implicit(System.String) declare in System.String
bool w_S_S_p_i4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_p_i4_s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef struct S_S_p_i4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_S_p_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.PenData GetLastPenContactEvent() declare in UnityEngine.Input
bool w_S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__ (*FuncToCall)(const void* method);
    struct S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__ ret = ((FuncToCall)methodPointer)(  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.PenData GetPenEvent(Int32) declare in UnityEngine.Input
bool w_S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__ (*FuncToCall)(int32_t p1, const void* method);
    struct S_S_r4r4_S_r4r4_i4r4r4i4S_r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// com.pixui.PxTRS ToTRS(UnityEngine.RectTransform) declare in com.pixui.PxMisc
bool w_S_S_r4r4_r4S_r4r4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4_r4S_r4r4__t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_S_r4r4_r4S_r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4_r4S_r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// RectRtRecord MyLerpRecord() declare in Assets.Scripts.UI.CardComponent.Item.UICardItem
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// RectRtRecord GetHopeToInfo(UnityEngine.RectTransform, Int32) declare in UnityEngine.UI.Extensions.RadialLayout
bool w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_toi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_toi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_ (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Bounds CalculateRelativeRectTransformBounds(UnityEngine.Transform) declare in UnityEngine.RectTransformUtility
bool w_S_S_r4r4r4_S_r4r4r4__o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Ray ScreenPointToRay(UnityEngine.Camera, UnityEngine.Vector2) declare in UnityEngine.RectTransformUtility
bool w_S_S_r4r4r4_S_r4r4r4__oS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__oS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Bounds CalculateRelativeRectTransformBounds(UnityEngine.Transform, UnityEngine.Transform) declare in UnityEngine.RectTransformUtility
bool w_S_S_r4r4r4_S_r4r4r4__oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Bounds GetAABB() declare in Assets.Scripts.Framework.AssetService.ActorAsset
bool w_S_S_r4r4r4_S_r4r4r4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Ray ViewportPointToRay(UnityEngine.Vector3) declare in UnityEngine.Camera
bool w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Ray ViewportPointToRay(UnityEngine.Vector3, MonoOrStereoscopicEye) declare in UnityEngine.Camera
bool w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_r4r4r4_S_r4r4r4__tS_r4r4r4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef struct S_S_r4r4r4_S_r4r4r4__ (*FuncToCall)(void*,struct S_r4r4r4_ p1, int32_t p2, const void* method);
    struct S_S_r4r4r4_S_r4r4r4__ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// GameWatchPlayerLogicInfo GetRealTimeWatchFormation(UInt32) declare in Assets.Scripts.GameSystem.GameWatchManager
bool w_S_S_u4u1u1i4i4i4o_oS_S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1__u1u1_tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u1u1i4i4i4o_oS_S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1__u1u1_tu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_S_u4u1u1i4i4i4o_oS_S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1__u1u1_ (*FuncToCall)(void*,uint32_t p1, const void* method);
    struct S_S_u4u1u1i4i4i4o_oS_S_S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_S_S_i4i4i4_S_r4r4r4_S_i4i4i4_u1u1u1_S_i4i4i4i4i4i4i4i4i4i4_S_oo_S_i4i4__S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1__u1u1_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// stGridEquipInfo GetCommonContainerGridByObjId(UInt32) declare in Assets.Scripts.GameLogic.EquipLinkerComponent
bool w_S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4_tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4_tu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4_ (*FuncToCall)(void*,uint32_t p1, const void* method);
    struct S_S_u4u4u4u4u4u4u4u4_u4u4u1u4u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UpgradeHeroRet CanUpgradeHero(Int32, UInt32) declare in Assets.Scripts.GameLogic.PlayerChessManager
bool w_S_bbbi4_ti4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_bbbi4_ti4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef struct S_bbbi4_ (*FuncToCall)(void*,int32_t p1, uint32_t p2, const void* method);
    struct S_bbbi4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Touch GetTouch(Int32) declare in UnityEngine.Input
bool w_S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_i4S_r4r4_S_r4r4_S_r4r4_r4i4i4i4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.LayerMask op_Implicit(Int32) declare in UnityEngine.LayerMask
bool w_S_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.SceneManagement.Scene get_scene() declare in UnityEngine.GameObject
bool w_S_i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Rendering.ShaderTagId FindPassTagValue(Int32, UnityEngine.Rendering.ShaderTagId) declare in UnityEngine.Shader
bool w_S_i4_ti4S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_ti4S_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_i4_* pp1 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv1);
    S_i4_ p1 = pp1 ? *pp1 : S_i4_ {};
        
    typedef struct S_i4_ (*FuncToCall)(void*,int32_t p1, struct S_i4_ p2, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Rendering.ShaderTagId FindPassTagValue(Int32, Int32, UnityEngine.Rendering.ShaderTagId) declare in UnityEngine.Shader
bool w_S_i4_ti4i4S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4_ti4i4S_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
             // LuaValToCSVal struct
    S_i4_* pp2 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv2);
    S_i4_ p2 = pp2 ? *pp2 : S_i4_ {};
        
    typedef struct S_i4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, struct S_i4_ p3, const void* method);
    struct S_i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Resolution get_currentResolution() declare in UnityEngine.Screen
bool w_S_i4i4S_u4u4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4S_u4u4__");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_i4i4S_u4u4__ (*FuncToCall)(const void* method);
    struct S_i4i4S_u4u4__ ret = ((FuncToCall)methodPointer)(  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2Int get_mainWindowPosition() declare in UnityEngine.Screen
bool w_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_i4i4_ (*FuncToCall)(const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// VInt2 op_UnaryNegation(VInt2) declare in VInt2
bool w_S_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
        
    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4_ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// VInt2 op_Addition(VInt2, VInt2) declare in VInt2
bool w_S_i4i4_S_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4_S_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4_ p1, struct S_i4i4_ p2, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// VInt2 Rotate(VInt2, Int32) declare in VInt2
bool w_S_i4i4_S_i4i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4_ p1, int32_t p2, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// VInt2 FromInt3XZ(VInt3) declare in VInt2
bool w_S_i4i4_S_i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_i4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4_>(apis, env, _sv0);
    S_i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4_ {};
        
    typedef struct S_i4i4_ (*FuncToCall)(struct S_i4i4i4_ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// VInt2 op_Explicit(UnityEngine.Vector2) declare in VInt2
bool w_S_i4i4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef struct S_i4i4_ (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2Int get_softness() declare in UnityEngine.UI.RectMask2D
bool w_S_i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// VInt2 FixHeroDragEndCoord(VInt2) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_S_i4i4_tS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_tS_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
        
    typedef struct S_i4i4_ (*FuncToCall)(void*,struct S_i4i4_ p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// VInt2 GetCellCoord(UnityEngine.Vector3, Boolean, Boolean) declare in Assets.Scripts.GameLogic.Project8SceneManagement
bool w_S_i4i4_tS_r4r4r4_DbDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_tS_r4r4r4_DbDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef struct S_i4i4_ (*FuncToCall)(void*,struct S_r4r4r4_ p1, bool p2, bool p3, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// VInt2 GetCellCoord(UnityEngine.Vector3, Boolean, Boolean) declare in Assets.Scripts.GameLogic.Project8BattleField
bool w_S_i4i4_tS_r4r4r4_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_tS_r4r4r4_bb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef struct S_i4i4_ (*FuncToCall)(void*,struct S_r4r4r4_ p1, bool p2, bool p3, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// VInt2 RecommendIndexToCoord(Int32) declare in Assets.Scripts.GameLogic.Project8BattleGrid
bool w_S_i4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_ti4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// VInt2 FixCardDragEndCoord(Int32, Int32, VInt2) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_S_i4i4_ti4i4S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4_ti4i4S_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
             // LuaValToCSVal struct
    S_i4i4_* pp2 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv2);
    S_i4i4_ p2 = pp2 ? *pp2 : S_i4i4_ {};
        
    typedef struct S_i4i4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, struct S_i4i4_ p3, const void* method);
    struct S_i4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// VInt3 ToInt3XZ(VInt2) declare in VInt2
bool w_S_i4i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4_S_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
        
    typedef struct S_i4i4i4_ (*FuncToCall)(struct S_i4i4_ p1, const void* method);
    struct S_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.SafeAreaBoundBox get_CurrentPhysicalSafeAreaBoundBox() declare in Assets.Scripts.Framework.UI.DeviceService
bool w_S_i4i4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.LightBakingOutput get_bakingOutput() declare in UnityEngine.Light
bool w_S_i4i4i4i4b_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4b_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_i4i4i4i4b_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4b_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.RenderTextureDescriptor get_descriptor() declare in UnityEngine.RenderTexture
bool w_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4i4i4i4i4i4i4i4i4i4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(System.Object) declare in System.Convert
bool w_S_i4i4i4i4u8_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_O");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(System.Object, System.IFormatProvider) declare in System.Convert
bool w_S_i4i4i4i4u8_Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_Oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(System.Decimal) declare in System.Convert
bool w_S_i4i4i4i4u8_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(System.DateTime) declare in System.Convert
bool w_S_i4i4i4i4u8_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(struct S_u8_ p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(Boolean) declare in System.Convert
bool w_S_i4i4i4i4u8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(bool p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(Char) declare in System.Convert
bool w_S_i4i4i4i4u8_c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_c");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppChar p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(SByte) declare in System.Convert
bool w_S_i4i4i4i4u8_i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_i1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(int8_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(Int16) declare in System.Convert
bool w_S_i4i4i4i4u8_i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_i2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(int16_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(Int32) declare in System.Convert
bool w_S_i4i4i4i4u8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(Int64) declare in System.Convert
bool w_S_i4i4i4i4u8_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_i8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(int64_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(Single) declare in System.Convert
bool w_S_i4i4i4i4u8_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(float p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(Double) declare in System.Convert
bool w_S_i4i4i4i4u8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_r8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(double p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(System.String) declare in System.Convert
bool w_S_i4i4i4i4u8_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(System.String, System.IFormatProvider) declare in System.Convert
bool w_S_i4i4i4i4u8_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_so");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(Byte) declare in System.Convert
bool w_S_i4i4i4i4u8_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_u1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(uint8_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(UInt16) declare in System.Convert
bool w_S_i4i4i4i4u8_u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_u2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(uint16_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(UInt32) declare in System.Convert
bool w_S_i4i4i4i4u8_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(uint32_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Decimal ToDecimal(UInt64) declare in System.Convert
bool w_S_i4i4i4i4u8_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4i4i4i4u8_u8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_i4i4i4i4u8_ (*FuncToCall)(uint64_t p1, const void* method);
    struct S_i4i4i4i4u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// MinMaxGradient get_startColor() declare in UnityEngine.ParticleSystem+MainModule
bool w_S_i4ooS_r4r4r4r4_S_r4r4r4r4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4ooS_r4r4r4r4_S_r4r4r4r4__t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_i4ooS_r4r4r4r4_S_r4r4r4r4__ (*FuncToCall)(void*,const void* method);
    struct S_i4ooS_r4r4r4r4_S_r4r4r4r4__ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.RenderBuffer get_colorBuffer() declare in UnityEngine.RenderTexture
bool w_S_i4p_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4p_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_i4p_ (*FuncToCall)(void*,const void* method);
    struct S_i4p_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// MinMaxCurve get_startDelay() declare in UnityEngine.ParticleSystem+MainModule
bool w_S_i4r4oor4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i4r4oor4r4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_i4r4oor4r4_ (*FuncToCall)(void*,const void* method);
    struct S_i4r4oor4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.TimeSpan op_Subtraction(System.DateTime, System.DateTime) declare in System.DateTime
bool w_S_i8_S_u8_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_S_u8_S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
             // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef struct S_i8_ (*FuncToCall)(struct S_u8_ p1, struct S_u8_ p2, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.TimeSpan get_MatchTimeout() declare in System.Text.RegularExpressions.Regex
bool w_S_i8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_i8_ (*FuncToCall)(void*,const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.TimeSpan Subtract(System.DateTime) declare in System.DateTime
bool w_S_i8_tS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8_tS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef struct S_i8_ (*FuncToCall)(void*,struct S_u8_ p1, const void* method);
    struct S_i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// VFactor Atan2(Int32, Int32) declare in SGW
bool w_S_i8i8_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i8_i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef struct S_i8i8_ (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    struct S_i8i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// VFactor Sin(Int64, Int64) declare in SGW
bool w_S_i8i8_i8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_i8i8_i8i8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
        
    typedef struct S_i8i8_ (*FuncToCall)(int64_t p1, int64_t p2, const void* method);
    struct S_i8i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.TextGenerationSettings GetGenerationSettings(UnityEngine.Vector2) declare in UnityEngine.UI.Text
bool w_S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_tS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_tS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef struct S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ (*FuncToCall)(void*,struct S_r4r4_ p1, const void* method);
    struct S_oS_r4r4r4r4_i4r4br4i4i4bbi4i4bi4i4S_r4r4_S_r4r4_bb_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Threading.CancellationToken get_exitCancellationToken() declare in UnityEngine.Application
bool w_S_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_o_ (*FuncToCall)(const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Threading.CancellationToken get_destroyCancellationToken() declare in UnityEngine.MonoBehaviour
bool w_S_o_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_o_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_o_ (*FuncToCall)(void*,const void* method);
    struct S_o_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Enumerator GetEnumerator() declare in System.Collections.Generic.Dictionary`2[ResData.ActorAbilitySymmetryType,System.Int32]
bool w_S_oi4i4S_i4i4_i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4S_i4i4_i4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_oi4i4S_i4i4_i4_ (*FuncToCall)(void*,const void* method);
    struct S_oi4i4S_i4i4_i4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Enumerator GetEnumerator() declare in System.Collections.Generic.Dictionary`2[System.Int32,OSProto.IN_GAME_PRESENTATION_DATA+Lord_SkillInfo]
bool w_S_oi4i4S_i4o_i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4S_i4o_i4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_oi4i4S_i4o_i4_ (*FuncToCall)(void*,const void* method);
    struct S_oi4i4S_i4o_i4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Enumerator GetEnumerator() declare in System.Collections.Generic.Dictionary`2[System.String,System.String]
bool w_S_oi4i4S_ss_i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4S_ss_i4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_oi4i4S_ss_i4_ (*FuncToCall)(void*,const void* method);
    struct S_oi4i4S_ss_i4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Enumerator get_ForbidUIIter() declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_S_oi4i4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4i4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_oi4i4i4_ (*FuncToCall)(void*,const void* method);
    struct S_oi4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Project8RoundStatisticInfo get_RoundInfo() declare in Assets.Scripts.GameSystem.RoundStatisticData
bool w_S_oi4i4i4u4u4o_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4i4u4u4o_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_oi4i4i4u4u4o_ (*FuncToCall)(void*,const void* method);
    struct S_oi4i4i4u4u4o_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Enumerator GetEnumerator() declare in System.Collections.Generic.List`1[UIEventDelegate]
bool w_S_oi4i4o_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4o_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_oi4i4o_ (*FuncToCall)(void*,const void* method);
    struct S_oi4i4o_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Enumerator GetEnumerator() declare in System.Collections.Generic.List`1[System.String]
bool w_S_oi4i4s_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oi4i4s_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_oi4i4s_ (*FuncToCall)(void*,const void* method);
    struct S_oi4i4s_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.InterfaceMapping GetInterfaceMap(System.Type) declare in System.Type
bool w_S_oooo_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooo_to");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef struct S_oooo_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_oooo_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Trails GetTrails() declare in UnityEngine.ParticleSystem
bool w_S_oooooi4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_oooooi4i4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_oooooi4i4_ (*FuncToCall)(void*,const void* method);
    struct S_oooooi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.RuntimeTypeHandle GetTypeHandle(System.Object) declare in System.Type
bool w_S_p_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_O");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef struct S_p_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.RuntimeTypeHandle get_TypeHandle() declare in System.Type
bool w_S_p_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_p_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_p_ (*FuncToCall)(void*,const void* method);
    struct S_p_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 get_zero() declare in UnityEngine.Vector2
bool w_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 op_Explicit(VInt2) declare in VInt2
bool w_S_r4r4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_i4i4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 Perpendicular(UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 Scale(UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
             
    // LuaValToCSVal Pstruct
    S_r4r4_* p2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_* p3, float p4, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single, Single) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
             
    // LuaValToCSVal Pstruct
    S_r4r4_* p2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_* p3, float p4, float p5, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single, Single, Single) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_PS_r4r4_r4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
             
    // LuaValToCSVal Pstruct
    S_r4r4_* p2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_* p3, float p4, float p5, float p6, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 Lerp(UnityEngine.Vector2, UnityEngine.Vector2, Single) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_S_r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 PixelAdjustPoint(UnityEngine.Vector2, UnityEngine.Transform, UnityEngine.Canvas) declare in UnityEngine.RectTransformUtility
bool w_S_r4r4_S_r4r4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 ClampMagnitude(UnityEngine.Vector2, Single) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4_ p1, float p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector3) declare in UnityEngine.Vector2
bool w_S_r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector4) declare in UnityEngine.Vector4
bool w_S_r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 NormalizedToPoint(UnityEngine.Rect, UnityEngine.Vector2) declare in UnityEngine.Rect
bool w_S_r4r4_S_r4r4r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_S_r4r4r4r4_S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 ConvertToVector2(OSProto.HangPivotType) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_S_r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_r4r4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 WorldToScreenPoint(UnityEngine.Camera, UnityEngine.Vector3) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_S_r4r4_oS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_oS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 ScreenPointToLocalPointInRectangle(UnityEngine.RectTransform, UnityEngine.Camera, UnityEngine.Vector2) declare in LuaCallCSharpInteraction
bool w_S_r4r4_ooS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_ooS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
             // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_r4r4_ p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 WorldToUguiPoint(UnityEngine.Camera, UnityEngine.RectTransform, UnityEngine.Vector3) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_S_r4r4_ooS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_ooS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
             // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_r4r4r4_ p3, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 op_Multiply(Single, UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_S_r4r4_r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_r4S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(float p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SmoothDampFloatResult SmoothDampFloat(Single, Single, Single, Single) declare in LuaCallCSharpInteraction
bool w_S_r4r4_r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_r4r4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef struct S_r4r4_ (*FuncToCall)(float p1, float p2, float p3, float p4, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 GetVector2(System.String, UnityEngine.Vector2) declare in PlayerPrefsX
bool w_S_r4r4_sS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_sS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(Il2CppString* p1, struct S_r4r4_ p2, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 ToVector2(com.pixui.NativeRect) declare in com.pixui.PxMisc
bool w_S_r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 PixelAdjustPoint(UnityEngine.Vector2) declare in UnityEngine.UI.Graphic
bool w_S_r4r4_tS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_tS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef struct S_r4r4_ (*FuncToCall)(void*,struct S_r4r4_ p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 GetTextureOffset(Int32) declare in UnityEngine.Material
bool w_S_r4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_ti4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_r4r4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 AverageVector(FingerPropertyGetterDelegate`1) declare in FingerList
bool w_S_r4r4_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_to");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2 GetTextureOffset(System.String) declare in UnityEngine.Material
bool w_S_r4r4_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4_ts");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef struct S_r4r4_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 get_zero() declare in UnityEngine.Vector3
bool w_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_r4r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 op_Implicit(UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_S_r4r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 ScreenToWorldPoint(UnityEngine.Vector2, Single) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_S_r4r4r4_S_r4r4_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4_Dr4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
         // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 Normalize(UnityEngine.Vector3) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 Scale(UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_* p3, float p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single, Single) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_* p3, float p4, float p5, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single, Single, Single) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_PS_r4r4r4_r4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, struct S_r4r4r4_* p3, float p4, float p5, float p6, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 Slerp(UnityEngine.Vector3, UnityEngine.Vector3, Single) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 RotateTowards(UnityEngine.Vector3, UnityEngine.Vector3, Single, Single) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, float p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 ClampMagnitude(UnityEngine.Vector3, Single) declare in UnityEngine.Vector3
bool w_S_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 ToEulerAngles(UnityEngine.Quaternion) declare in UnityEngine.Quaternion
bool w_S_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 op_Multiply(UnityEngine.Quaternion, UnityEngine.Vector3) declare in UnityEngine.Quaternion
bool w_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_S_r4r4r4r4_S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 GetUguiPosFromRt(UnityEngine.RectTransform) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_S_r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 ScreenToWorldPoint(UnityEngine.Camera, UnityEngine.Vector2, Single) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_S_r4r4r4_oS_r4r4_Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_oS_r4r4_Dr4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (lua_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
         // LuaValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, float p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 TransformRelativePosToTargetSpace(UnityEngine.Transform, UnityEngine.Vector3) declare in LuaCallCSharpInteraction
bool w_S_r4r4r4_oS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_oS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 RemapPosition(Assets.Scripts.GameLogic.Project8PlayerInstance, UnityEngine.Vector3, Boolean, Boolean) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_S_r4r4r4_oS_r4r4r4_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_oS_r4r4r4_bb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, bool p3, bool p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 GetKeepNodeScale(UnityEngine.RectTransform, UnityEngine.RectTransform, Single) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_S_r4r4r4_ooDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_ooDr4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
         // LuaValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 tweenOnCurveVector(LTDescr, Single) declare in LeanTween
bool w_S_r4r4r4_or4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_or4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppObject* p1, float p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 op_Multiply(Single, UnityEngine.Vector3) declare in UnityEngine.Vector3
bool w_S_r4r4r4_r4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_r4S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(float p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 GetScale(Single, Single, Single) declare in com.pixui.PxMisc
bool w_S_r4r4r4_r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_r4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 GetVector3(System.String) declare in PlayerPrefsX
bool w_S_r4r4r4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 GetVector3(System.String, UnityEngine.Vector3) declare in PlayerPrefsX
bool w_S_r4r4r4_sS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_sS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 get_anchoredPosition3D() declare in UnityEngine.RectTransform
bool w_S_r4r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 GetGridWorldPoint(VInt2) declare in Assets.Scripts.GameLogic.Project8BattleField
bool w_S_r4r4r4_tS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tS_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,struct S_i4i4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 GetLocalPositionByAnchorPosition(UnityEngine.RectTransform, UnityEngine.Vector2) declare in ExtRectTransform
bool w_S_r4r4r4_tS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,struct S_r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 TransformDirection(UnityEngine.Vector3) declare in UnityEngine.Transform
bool w_S_r4r4r4_tS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 WorldToScreenPoint(UnityEngine.Vector3, MonoOrStereoscopicEye) declare in UnityEngine.Camera
bool w_S_r4r4r4_tS_r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tS_r4r4r4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4_ p1, int32_t p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 GetPosition(Int32) declare in UnityEngine.LineRenderer
bool w_S_r4r4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_ti4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 GetCoordCenter(Int32, Int32) declare in Assets.Scripts.GameLogic.Project8SceneManagement
bool w_S_r4r4r4_ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_ti4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 RemappedPositionImpl(Assets.Scripts.GameLogic.Project8PlayerInstance, UnityEngine.Vector3, Boolean) declare in Assets.Scripts.GameLogic.Project8SceneManagement
bool w_S_r4r4r4_toS_r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_toS_r4r4r4_b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, struct S_r4r4r4_ p2, bool p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 TransformDirection(Single, Single, Single) declare in UnityEngine.Transform
bool w_S_r4r4r4_tr4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tr4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,float p1, float p2, float p3, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 GetHeroHpBarUIPos(UInt32) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_S_r4r4r4_tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,uint32_t p1, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 GetHeroWorldPosition(UInt32, VInt2) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_S_r4r4r4_tu4S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tu4S_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,uint32_t p1, struct S_i4i4_ p2, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3 GetScenePos(UInt32, VInt2, Boolean, Boolean) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_S_r4r4r4_tu4S_i4i4_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4_tu4S_i4i4_bb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef struct S_r4r4r4_ (*FuncToCall)(void*,uint32_t p1, struct S_i4i4_ p2, bool p3, bool p4, const void* method);
    struct S_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PlaybackState GetPlaybackState() declare in UnityEngine.ParticleSystem
bool w_S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4i4S_r4r4S_u4u4u4u4__S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4__r4r4r4r4r4r4i4_S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_S_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4_S_u4u4u4u4___S_r4_S_S_u4u4u4u4_r4_S_r4__ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Quaternion get_identity() declare in UnityEngine.Quaternion
bool w_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_r4r4r4r4_ (*FuncToCall)(const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector4 op_Implicit(UnityEngine.Vector2) declare in UnityEngine.Vector4
bool w_S_r4r4r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Quaternion LookRotation(UnityEngine.Vector3) declare in UnityEngine.Quaternion
bool w_S_r4r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Quaternion FromToRotation(UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Quaternion
bool w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Quaternion AxisAngle(UnityEngine.Vector3, Single) declare in UnityEngine.Quaternion
bool w_S_r4r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Quaternion Inverse(UnityEngine.Quaternion) declare in UnityEngine.Quaternion
bool w_S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Quaternion op_Multiply(UnityEngine.Quaternion, UnityEngine.Quaternion) declare in UnityEngine.Quaternion
bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Quaternion Slerp(UnityEngine.Quaternion, UnityEngine.Quaternion, Single) declare in UnityEngine.Quaternion
bool w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, float p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Color op_Multiply(UnityEngine.Color, Single) declare in UnityEngine.Color
bool w_S_r4r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_S_r4r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(struct S_r4r4r4r4_ p1, float p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.AccelerationEvent GetAccelerationEvent(Int32) declare in UnityEngine.Input
bool w_S_r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Color GetQualityDarkColor(Int32, System.String) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_S_r4r4r4r4_i4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_i4Ds");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);
    typedef struct S_r4r4r4r4_ (*FuncToCall)(int32_t p1, Il2CppString* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Rect PixelAdjustRect(UnityEngine.RectTransform, UnityEngine.Canvas) declare in UnityEngine.RectTransformUtility
bool w_S_r4r4r4r4_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Color CorrelatedColorTemperatureToRGB(Single) declare in UnityEngine.Mathf
bool w_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Quaternion AngleAxis(Single, UnityEngine.Vector3) declare in UnityEngine.Quaternion
bool w_S_r4r4r4r4_r4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, struct S_r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Color op_Multiply(Single, UnityEngine.Color) declare in UnityEngine.Color
bool w_S_r4r4r4r4_r4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Quaternion GetEuler(Single, Single, Single) declare in com.pixui.PxMisc
bool w_S_r4r4r4r4_r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Color HSVToRGB(Single, Single, Single, Boolean) declare in UnityEngine.Color
bool w_S_r4r4r4r4_r4r4r4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, bool p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Rect MinMaxRect(Single, Single, Single, Single) declare in UnityEngine.Rect
bool w_S_r4r4r4r4_r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_r4r4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(float p1, float p2, float p3, float p4, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Color HexToColor(System.String) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_S_r4r4r4r4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Quaternion GetQuaternion(System.String, UnityEngine.Quaternion) declare in PlayerPrefsX
bool w_S_r4r4r4r4_sS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_sS_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4r4_ p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Color ToUColor(com.pixui.NativeColor) declare in com.pixui.PxMisc
bool w_S_r4r4r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector4 GetSoftMaskRect(Boolean) declare in UnityEngine.UI.Mask
bool w_S_r4r4r4r4_tDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,bool p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Rect Add(UnityEngine.Rect) declare in UnityEngine.RectOffset
bool w_S_r4r4r4r4_tS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tS_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector4 GetDrawingDimensions(Boolean) declare in UnityEngine.UI.Image
bool w_S_r4r4r4r4_tb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,bool p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Rect GetItemPosRect(Int32) declare in Timi.TimiRegularLayout
bool w_S_r4r4r4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ti4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Rect GetScreenShotRect(UnityEngine.RectTransform) declare in Assets.Scripts.GameSystem.ShareCaptureSys
bool w_S_r4r4r4r4_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_to");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Color GetColor(System.String) declare in UnityEngine.Material
bool w_S_r4r4r4r4_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_ts");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Color GetCellColor(UInt32) declare in Assets.Scripts.GameLogic.Project8BattleField
bool w_S_r4r4r4r4_tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_tu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(void*,uint32_t p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Color GetPropIconColor(UInt32) declare in PBData.PBDataAux
bool w_S_r4r4r4r4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_r4r4r4r4_ (*FuncToCall)(uint32_t p1, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Color GetQualityColor(UInt32, System.String) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_S_r4r4r4r4_u4Ds(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4_u4Ds");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);
    typedef struct S_r4r4r4r4_ (*FuncToCall)(uint32_t p1, Il2CppString* p2, const void* method);
    struct S_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// com.pixui.NativeMatrix ToNative(com.pixui.PxMatrix) declare in com.pixui.PxMisc
bool w_S_r4r4r4r4r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// com.pixui.PxMatrix Translate(com.pixui.NativeMatrix, Single, Single) declare in com.pixui.PxMisc
bool w_S_r4r4r4r4r4r4_tr4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4_tr4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef struct S_r4r4r4r4r4r4_ (*FuncToCall)(void*,float p1, float p2, const void* method);
    struct S_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Matrix4x4 GetGlobalMatrix(Int32) declare in UnityEngine.Shader
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Matrix4x4 GetGlobalMatrix(System.String) declare in UnityEngine.Shader
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Matrix4x4 get_worldToLocalMatrix() declare in UnityEngine.Transform
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Matrix4x4 CalculateObliqueMatrix(UnityEngine.Vector4) declare in UnityEngine.Camera
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_tS_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Matrix4x4 GetStereoNonJitteredProjectionMatrix(StereoscopicEye) declare in UnityEngine.Camera
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ti4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Matrix4x4 GetMatrix(System.String) declare in UnityEngine.Material
bool w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.GraphicsBufferHandle GetBuffer(System.String) declare in UnityEngine.Material
bool w_S_u4_ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4_ts");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef struct S_u4_ (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    struct S_u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Tuple`2[System.UInt32,System.Int32] GetWaitUseCardInfo(Int32[]) declare in Assets.Scripts.GameLogic.PlayerDeckComponent
bool w_S_u4i4_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4_to");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef struct S_u4i4_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_u4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Project8RelationMod GetModParam(ResData.RELATION_MOD_TYPE) declare in Assets.Scripts.GameLogic.PlayerRelation
bool w_S_u4i4i4i4_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4i4i4i4_ti4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u4i4i4i4_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_u4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker] op_Explicit(Assets.Scripts.GameLogic.ActorLinker) declare in PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]
bool w_S_u4o_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4o_o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef struct S_u4o_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_u4o_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PooledCollections.PoolObjHandle`1[Assets.Scripts.Framework.UI.UIPrefab2DClass] OpenEquipTipSync(Assets.Scripts.Framework.UI.UIPrefab2DClass, stShowEquipmentInfo, System.Action, Boolean, System.Action`1[PooledCollections.PoolObjHandle`1[Assets.Scripts.Framework.UI.UIPrefab2DClass]]) declare in Assets.Scripts.GameLogic.EquipUtil
bool w_S_u4o_ooDoDbDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4o_ooDoDbDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2); // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
                // LuaValToCSVal ref with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 4, TIp4);
    typedef struct S_u4o_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, Il2CppObject* p5, const void* method);
    struct S_u4o_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PooledCollections.PoolObjHandle`1[Assets.Scripts.Framework.UI.UILuaPrefabClass] OpenEquipHuanHuaDetailInfoTips(Assets.Scripts.Framework.UI.UIPrefab2DClass, stShowEquipmentInfo, UInt32) declare in Assets.Scripts.GameLogic.EquipUtil
bool w_S_u4o_oou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4o_oou4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef struct S_u4o_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, uint32_t p3, const void* method);
    struct S_u4o_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker] get_LordActor() declare in Assets.Scripts.GameLogic.PlayerLordComponent
bool w_S_u4o_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4o_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_u4o_ (*FuncToCall)(void*,const void* method);
    struct S_u4o_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.BaseCard] GetOrCreateCardByConfigID(Int32) declare in Assets.Scripts.GameLogic.CardManager
bool w_S_u4o_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4o_ti4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u4o_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_u4o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.BuffLinker] GetByConfigId(Int32, Int32) declare in Assets.Scripts.GameLogic.BuffLinkerComponent
bool w_S_u4o_ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4o_ti4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef struct S_u4o_ (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    struct S_u4o_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.BaseCard] GetOrCreateCard(PileItem) declare in Assets.Scripts.GameLogic.CardManager
bool w_S_u4o_to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4o_to");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef struct S_u4o_ (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    struct S_u4o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PooledCollections.PoolObjHandle`1[Assets.Scripts.Framework.UI.UILuaPrefabClass] GetLuaPrefab(System.String, Assets.Scripts.Framework.UI.UIPrefabBaseClass) declare in UIPoolService
bool w_S_u4o_tsDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4o_tsDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);
    typedef struct S_u4o_ (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_u4o_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PooledCollections.PoolObjHandle`1[Assets.Scripts.Framework.UI.UILuaPrefabClass] AsyncGetLuaPrefab(System.String, Assets.Scripts.Framework.UI.UIPrefabBaseClass, System.Action`1[PooledCollections.PoolObjHandle`1[Assets.Scripts.Framework.UI.UILuaPrefabClass]]) declare in UIPoolService
bool w_S_u4o_tsDoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4o_tsDoDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef struct S_u4o_ (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_u4o_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PooledCollections.PoolObjHandle`1[Assets.Scripts.Framework.UI.UILuaPrefabClass] GetLuaPrefab(System.String, Assets.Scripts.Framework.UI.UIPrefab2DClass) declare in Assets.Scripts.UI.TipsManager
bool w_S_u4o_tso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4o_tso");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef struct S_u4o_ (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_u4o_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PooledCollections.PoolObjHandle`1[Assets.Scripts.Framework.UI.UILuaPrefabClass] AsyncGetLuaPrefab(System.String, Assets.Scripts.Framework.UI.UIPrefab2DClass, System.Action`1[PooledCollections.PoolObjHandle`1[Assets.Scripts.Framework.UI.UILuaPrefabClass]]) declare in Assets.Scripts.UI.TipsManager
bool w_S_u4o_tsoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4o_tsoo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef struct S_u4o_ (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    struct S_u4o_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker] GetActor(UInt32) declare in Assets.Scripts.GameLogic.ActorManager
bool w_S_u4o_tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4o_tu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u4o_ (*FuncToCall)(void*,uint32_t p1, const void* method);
    struct S_u4o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.BaseCard] GetOrCreateCard(UInt32, Int32) declare in Assets.Scripts.GameLogic.CardManager
bool w_S_u4o_tu4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4o_tu4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef struct S_u4o_ (*FuncToCall)(void*,uint32_t p1, int32_t p2, const void* method);
    struct S_u4o_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker] GetActorLinker(UInt32) declare in Assets.Scripts.GameLogic.ActorHelper
bool w_S_u4o_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4o_u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u4o_ (*FuncToCall)(uint32_t p1, const void* method);
    struct S_u4o_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Project8NSelectOneInfos get_infos() declare in Assets.Scripts.GameLogic.PlayerNSelectOne
bool w_S_u4u1o_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u1o_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_u4u1o_ (*FuncToCall)(void*,const void* method);
    struct S_u4u1o_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Project8NSelectOneInfo GetCurrentSelectInfo() declare in Assets.Scripts.GameLogic.PlayerNSelectOne
bool w_S_u4u4i4_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4i4_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_u4u4i4_ (*FuncToCall)(void*,const void* method);
    struct S_u4u4i4_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// stPlayerExtraPublicInfo get_PublicExtraInfo() declare in Assets.Scripts.GameLogic.Project8PlayerInstance
bool w_S_u4u4u1_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u1_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_u4u4u1_ (*FuncToCall)(void*,const void* method);
    struct S_u4u4u1_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// stEquipItem GetEquip(UInt32) declare in Assets.Scripts.GameLogic.EquipLinkerComponent
bool w_S_u4u4u4u4u4u4u4u4_tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4u4u4u4u4_tu4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u4u4u4u4u4u4u4u4_ (*FuncToCall)(void*,uint32_t p1, const void* method);
    struct S_u4u4u4u4u4u4u4u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Project8CastLordSkillContext GetOrCreateSkillContext(OSProto.LordSkillSlotID) declare in Assets.Scripts.UI.InGameCommon.UILordSkillDataItem
bool w_S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_ti4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime get_Now() declare in System.DateTime
bool w_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_u8_ (*FuncToCall)(const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(System.Object) declare in System.Convert
bool w_S_u8_O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_O");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppObject* p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(System.Object, System.IFormatProvider) declare in System.Convert
bool w_S_u8_Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_Oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime Parse(System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTime
bool w_S_u8_S_S_p_i4_DoDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_S_p_i4_DoDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
            // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1); // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef struct S_u8_ (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTime
bool w_S_u8_S_S_p_i4_S_S_p_i4_oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_S_p_i4_S_S_p_i4_oDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
             // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
         // LuaValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef struct S_u8_ (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, Il2CppObject* p3, int32_t p4, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTime
bool w_S_u8_S_S_p_i4_ooDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_S_p_i4_ooDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
         // LuaValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef struct S_u8_ (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(System.Decimal) declare in System.Convert
bool w_S_u8_S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef struct S_u8_ (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(System.DateTime) declare in System.Convert
bool w_S_u8_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime op_Addition(System.DateTime, System.TimeSpan) declare in System.DateTime
bool w_S_u8_S_u8_S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_S_i8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
             // LuaValToCSVal struct
    S_i8_* pp1 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv1);
    S_i8_ p1 = pp1 ? *pp1 : S_i8_ {};
        
    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p1, struct S_i8_ p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime SpecifyKind(System.DateTime, System.DateTimeKind) declare in System.DateTime
bool w_S_u8_S_u8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_S_u8_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef struct S_u8_ (*FuncToCall)(struct S_u8_ p1, int32_t p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(Boolean) declare in System.Convert
bool w_S_u8_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(bool p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(Char) declare in System.Convert
bool w_S_u8_c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_c");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppChar p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(SByte) declare in System.Convert
bool w_S_u8_i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(int8_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(Int16) declare in System.Convert
bool w_S_u8_i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(int16_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(Int32) declare in System.Convert
bool w_S_u8_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(int32_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToUtcTime2Local(Int64) declare in Utility
bool w_S_u8_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_i8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(int64_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(Single) declare in System.Convert
bool w_S_u8_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(float p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(Double) declare in System.Convert
bool w_S_u8_r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_r8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(double p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(System.String) declare in System.Convert
bool w_S_u8_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(System.String, System.IFormatProvider) declare in System.Convert
bool w_S_u8_so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_so");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime Parse(System.String, System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTime
bool w_S_u8_soi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_soi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTime
bool w_S_u8_sooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_sooi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ParseExact(System.String, System.String, System.IFormatProvider) declare in System.DateTime
bool w_S_u8_sso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_sso");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.DateTimeStyles) declare in System.DateTime
bool w_S_u8_ssoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ssoi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef struct S_u8_ (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime get_Date() declare in System.DateTime
bool w_S_u8_t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_t");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_u8_ (*FuncToCall)(void*,const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime Add(System.TimeSpan) declare in System.DateTime
bool w_S_u8_tS_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tS_i8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
        
    typedef struct S_u8_ (*FuncToCall)(void*,struct S_i8_ p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime AddMonths(Int32) declare in System.DateTime
bool w_S_u8_ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ti4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(void*,int32_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime AddTicks(Int64) declare in System.DateTime
bool w_S_u8_ti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_ti8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(void*,int64_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime AddDays(Double) declare in System.DateTime
bool w_S_u8_tr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_tr8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(void*,double p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(Byte) declare in System.Convert
bool w_S_u8_u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_u1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(uint8_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(UInt16) declare in System.Convert
bool w_S_u8_u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_u2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(uint16_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(UInt32) declare in System.Convert
bool w_S_u8_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(uint32_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.DateTime ToDateTime(UInt64) declare in System.Convert
bool w_S_u8_u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8_u8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef struct S_u8_ (*FuncToCall)(uint64_t p1, const void* method);
    struct S_u8_ ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.DisplayInfo get_mainWindowDisplayInfo() declare in UnityEngine.Screen
bool w_S_u8i4i4S_u4u4_S_i4i4i4i4_s_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_S_u8i4i4S_u4u4_S_i4i4i4i4_s_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef struct S_u8i4i4S_u4u4_S_i4i4i4i4_s_ (*FuncToCall)(const void* method);
    struct S_u8i4i4S_u4u4_S_i4i4i4i4_s_ ret = ((FuncToCall)methodPointer)(  method);
	int r = DataTransfer::CopyValueType(apis, env, ret, TIret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean get_isLoadingLevel() declare in UnityEngine.Application
bool w_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef bool (*FuncToCall)(const void* method);
    bool ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean isTweening(UnityEngine.GameObject) declare in LeanTween
bool w_bDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bDo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    // LuaValToCSVal ref with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 0, TIp0);
    typedef bool (*FuncToCall)(Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsDBNull(System.Object) declare in System.Convert
bool w_bO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CheckParam(System.Object, Int32, System.Object[]) declare in Utility
bool w_bOi4VO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bOi4VO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, lua_args_len, 2);
            
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppArray* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ToBoolean(System.Object, System.IFormatProvider) declare in System.Convert
bool w_bOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bOo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsKeywordEnabled(UnityEngine.Rendering.GlobalKeyword ByRef) declare in UnityEngine.Shader
bool w_bPS_su4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_su4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_su4_* p0 = DataTransfer::GetPointer<S_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef bool (*FuncToCall)(struct S_su4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsHostActor(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker] ByRef) declare in Assets.Scripts.GameLogic.ActorHelper
bool w_bPS_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPS_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4o_* p0 = DataTransfer::GetPointer<S_u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef bool (*FuncToCall)(struct S_u4o_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetAkFileFuncitons(SByte*, Int32) declare in SGW
bool w_bPi1i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bPi1i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    int8_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int8_t>>::toCpp(apis, env, _sv0);
    int8_t* p0 = &up0;
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(int8_t* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret0 = converter::Converter<int8_t>::toScript(apis, env, *p0);
	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsPathRooted(System.ReadOnlySpan`1[System.Char]) declare in System.IO.Path
bool w_bS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.DateTime ByRef) declare in System.DateTime
bool w_bS_S_p_i4_PS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_PS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
             
    // LuaValToCSVal Pstruct
    S_u8_* p1 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_u8_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryFromBase64Chars(System.ReadOnlySpan`1[System.Char], System.Span`1[System.Byte], Int32 ByRef) declare in System.Convert
bool w_bS_S_p_i4_S_S_p_i4_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_Pi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
             // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
             
    // LuaValToCSVal P primitive
    int32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, int32_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret2 = converter::Converter<int32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryToBase64Chars(System.ReadOnlySpan`1[System.Byte], System.Span`1[System.Char], Int32 ByRef, System.Base64FormattingOptions) declare in System.Convert
bool w_bS_S_p_i4_S_S_p_i4_Pi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_Pi4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (lua_args_len > 3 && !converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
             // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
             
    // LuaValToCSVal P primitive
    int32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
 // LuaValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, int32_t* p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret2 = converter::Converter<int32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryJoin(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.Span`1[System.Char], Int32 ByRef) declare in System.IO.Path
bool w_bS_S_p_i4_S_S_p_i4_S_S_p_i4_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_S_S_p_i4_Pi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
             // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
             // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
             
    // LuaValToCSVal P primitive
    int32_t up3 = 0;
    if (3 < lua_args_len)
        up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, struct S_S_p_i4_ p3, int32_t* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret3 = converter::Converter<int32_t>::toScript(apis, env, *p3);
	apis->add_return(info, r);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryJoin(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.Span`1[System.Char], Int32 ByRef) declare in System.IO.Path
bool w_bS_S_p_i4_S_S_p_i4_S_S_p_i4_S_S_p_i4_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_S_S_p_i4_S_S_p_i4_Pi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!apis->is_object(env, _sv4)) return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
             // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
             // LuaValToCSVal struct
    S_S_p_i4_* pp2 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv2);
    S_S_p_i4_ p2 = pp2 ? *pp2 : S_S_p_i4_ {};
             // LuaValToCSVal struct
    S_S_p_i4_* pp3 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv3);
    S_S_p_i4_ p3 = pp3 ? *pp3 : S_S_p_i4_ {};
             
    // LuaValToCSVal P primitive
    int32_t up4 = 0;
    if (4 < lua_args_len)
        up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv4);
    int32_t* p4 = &up4;

    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, struct S_S_p_i4_ p3, struct S_S_p_i4_ p4, int32_t* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret4 = converter::Converter<int32_t>::toScript(apis, env, *p4);
	apis->add_return(info, r);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef) declare in System.DateTime
bool w_bS_S_p_i4_S_S_p_i4_oi4PS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_S_S_p_i4_oi4PS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!apis->is_object(env, _sv4)) return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
             // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
             
    // LuaValToCSVal Pstruct
    S_u8_* p4 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_u8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
        p4 = &up4;
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, struct S_S_p_i4_ p2, Il2CppObject* p3, int32_t p4, struct S_u8_* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret4;
    if (p4 == &up4)
    {
        ret4 = DataTransfer::CopyValueType(apis, env, *p4, TIp4);    
        apis->update_boxed_value(env, _sv4, ret4);
    }
    else
    {
        ret4 = apis->native_object_to_value(env, TIp4, p4, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryParse(System.ReadOnlySpan`1[System.Char], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef) declare in System.DateTime
bool w_bS_S_p_i4_oi4PS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_oi4PS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
             
    // LuaValToCSVal Pstruct
    S_u8_* p3 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_u8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
        p3 = &up3;
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppObject* p2, int32_t p3, struct S_u8_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret3;
    if (p3 == &up3)
    {
        ret3 = DataTransfer::CopyValueType(apis, env, *p3, TIp3);    
        apis->update_boxed_value(env, _sv3, ret3);
    }
    else
    {
        ret3 = apis->native_object_to_value(env, TIp3, p3, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryParseExact(System.ReadOnlySpan`1[System.Char], System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef) declare in System.DateTime
bool w_bS_S_p_i4_ooi4PS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_p_i4_ooi4PS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!apis->is_object(env, _sv4)) return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
             
    // LuaValToCSVal Pstruct
    S_u8_* p4 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_u8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
        p4 = &up4;
    }
        
    typedef bool (*FuncToCall)(struct S_S_p_i4_ p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, struct S_u8_* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret4;
    if (p4 == &up4)
    {
        ret4 = DataTransfer::CopyValueType(apis, env, *p4, TIp4);    
        apis->update_boxed_value(env, _sv4, ret4);
    }
    else
    {
        ret4 = apis->native_object_to_value(env, TIp4, p4, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean op_Equality(UnityEngine.Bounds, UnityEngine.Bounds) declare in UnityEngine.Bounds
bool w_bS_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_S_r4r4r4_S_r4r4r4__S_S_r4r4r4_S_r4r4r4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
             // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp1 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv1);
    S_S_r4r4r4_S_r4r4r4__ p1 = pp1 ? *pp1 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef bool (*FuncToCall)(struct S_S_r4r4r4_S_r4r4r4__ p1, struct S_S_r4r4r4_S_r4r4r4__ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean op_Equality(VInt2, VInt2) declare in VInt2
bool w_bS_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4_S_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef bool (*FuncToCall)(struct S_i4i4_ p1, struct S_i4i4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ToBoolean(System.Decimal) declare in System.Convert
bool w_bS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef bool (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean op_Equality(UnityEngine.Vector2, UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_bS_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsPointOnLineSeg(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_bS_r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_S_r4r4_S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsIntersection(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_bS_r4r4_S_r4r4_S_r4r4_S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_S_r4r4_S_r4r4_S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4_ p3, struct S_r4r4_ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsLineIntersectWithRect(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Rect) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_bS_r4r4_S_r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4_S_r4r4_S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4_ p1, struct S_r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean op_Equality(UnityEngine.Vector3, UnityEngine.Vector3) declare in UnityEngine.Vector3
bool w_bS_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4_S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean op_Equality(UnityEngine.Quaternion, UnityEngine.Quaternion) declare in UnityEngine.Quaternion
bool w_bS_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TheSame(UnityEngine.Color, UnityEngine.Color, UnityEngine.Color, UnityEngine.Color) declare in com.pixui.PxMisc
bool w_bS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4r4_ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Equals(com.pixui.NativeColor, com.pixui.NativeColor) declare in com.pixui.PxMisc
bool w_bS_u1u1u1u1_S_u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u1u1u1u1_S_u1u1u1u1_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_u1u1u1u1_>(apis, env, _sv0);
    S_u1u1u1u1_ p0 = pp0 ? *pp0 : S_u1u1u1u1_ {};
             // LuaValToCSVal struct
    S_u1u1u1u1_* pp1 = DataTransfer::GetPointer<S_u1u1u1u1_>(apis, env, _sv1);
    S_u1u1u1u1_ p1 = pp1 ? *pp1 : S_u1u1u1u1_ {};
        
    typedef bool (*FuncToCall)(struct S_u1u1u1u1_ p1, struct S_u1u1u1u1_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean op_Implicit(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]) declare in PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]
bool w_bS_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
        
    typedef bool (*FuncToCall)(struct S_u4o_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean op_Equality(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker], PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]) declare in PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]
bool w_bS_u4o_S_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4o_S_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
             // LuaValToCSVal struct
    S_u4o_* pp1 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv1);
    S_u4o_ p1 = pp1 ? *pp1 : S_u4o_ {};
        
    typedef bool (*FuncToCall)(struct S_u4o_ p1, struct S_u4o_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsFilterActorType(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker], UInt32, UInt32, UInt32) declare in Assets.Scripts.GameLogic.ActorHelper
bool w_bS_u4o_u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u4o_u4u4u4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
        
    typedef bool (*FuncToCall)(struct S_u4o_ p1, uint32_t p2, uint32_t p3, uint32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ToBoolean(System.DateTime) declare in System.Convert
bool w_bS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef bool (*FuncToCall)(struct S_u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Equals(System.DateTime, System.DateTime) declare in System.DateTime
bool w_bS_u8_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bS_u8_S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
             // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef bool (*FuncToCall)(struct S_u8_ p1, struct S_u8_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean AllFingersMoving(Finger[]) declare in FingerGesture
bool w_bVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bVo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if(lua_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, false))
            return false;        
    }
    // LuaValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, lua_args_len, 0);
            
    typedef bool (*FuncToCall)(Il2CppArray* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsValid(Single[]) declare in com.pixui.PxMisc
bool w_bVr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bVr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        if(lua_args_len > 0 && !converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
     
    // LuaValToCSVal primitive params
    Il2CppArray* p0 = Params<float>::PackPrimitive(apis, env, info, TIp0, lua_args_len, 0);

    typedef bool (*FuncToCall)(Il2CppArray* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ToBoolean(Boolean) declare in System.Convert
bool w_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bb");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Assert(Boolean, System.String, System.Object[]) declare in Assets.Plugins.Common.Log
bool w_bbDsVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bbDsVO");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
            // LuaValToCSVal string with default
    Il2CppString* p1 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 1);    // LuaValToCSVal ref params
    Il2CppArray* p2 = Params<void*>::PackRef(apis, env, info, TIp2, lua_args_len, 2);
            
    typedef bool (*FuncToCall)(bool p1, Il2CppString* p2, Il2CppArray* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ToBoolean(Char) declare in System.Convert
bool w_bc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bc");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(Il2CppChar p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ToBoolean(SByte) declare in System.Convert
bool w_bi1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(int8_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ToBoolean(Int16) declare in System.Convert
bool w_bi2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(int16_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CanStreamedLevelBeLoaded(Int32) declare in UnityEngine.Application
bool w_bi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryGetPlayConstParam(KeyType, Int32 ByRef) declare in PBData.PBDataAux
bool w_bi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef bool (*FuncToCall)(int32_t p1, int32_t* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetWindowVM(Int32, IntPtr ByRef, IntPtr ByRef) declare in com.pixui.PxContext
bool w_bi4PpPp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4PpPp");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         
    // LuaValToCSVal P not primitive
    void** p1 = nullptr;
 
    // LuaValToCSVal P not primitive
    void** p2 = nullptr;

    typedef bool (*FuncToCall)(int32_t p1, void** p2, void** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = apis->create_binary(env, *p1, 0);
	int ret2 = apis->create_binary(env, *p2, 0);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsPlayModInGroup(ResData.PLAYMOD_TYPE, ResData.PLAYMOD_GROUP_TYPE) declare in Utility
bool w_bi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean LoadDataAsync(Int32, Int32, Int32, System.String) declare in com.pixui.PxContext
bool w_bi4i4i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4i4i4s");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    typedef bool (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, Il2CppString* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean removeListener(Int32, System.Action`1[LTEvent]) declare in LeanTween
bool w_bi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4o");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef bool (*FuncToCall)(int32_t p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean StartRecordScreen(UnityEngine.RecordScreenTextureFormat, IntPtr) declare in UnityEngine.Application
bool w_bi4p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4p");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(int32_t p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CheckNoticeRed(Int32, System.String) declare in Assets.Scripts.GameNotice.NoticeHelper
bool w_bi4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi4s");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef bool (*FuncToCall)(int32_t p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ToBoolean(Int64) declare in System.Convert
bool w_bi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(int64_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryStartNoGCRegion(Int64, Boolean) declare in System.GC
bool w_bi8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi8b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(int64_t p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryStartNoGCRegion(Int64, Int64) declare in System.GC
bool w_bi8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi8i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(int64_t p1, int64_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryStartNoGCRegion(Int64, Int64, Boolean) declare in System.GC
bool w_bi8i8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bi8i8b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef bool (*FuncToCall)(int64_t p1, int64_t p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean HasDataByType(System.Type) declare in DataService
bool w_bo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsDefined(System.Type, System.Object) declare in System.Enum
bool w_boO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean RectangleContainsScreenPoint(UnityEngine.RectTransform, UnityEngine.Vector2) declare in UnityEngine.RectTransformUtility
bool w_boS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean RectangleContainsScreenPoint(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Camera) declare in UnityEngine.RectTransformUtility
bool w_boS_r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ScreenPointToLocalPointInRectangle(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Camera, UnityEngine.Vector2 ByRef) declare in UnityEngine.RectTransformUtility
bool w_boS_r4r4_oPS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_oPS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
             
    // LuaValToCSVal Pstruct
    S_r4r4_* p3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
        p3 = &up3;
    }
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, Il2CppObject* p3, struct S_r4r4_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret3;
    if (p3 == &up3)
    {
        ret3 = DataTransfer::CopyValueType(apis, env, *p3, TIp3);    
        apis->update_boxed_value(env, _sv3, ret3);
    }
    else
    {
        ret3 = apis->native_object_to_value(env, TIp3, p3, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ScreenPointToWorldPointInRectangle(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Camera, UnityEngine.Vector3 ByRef) declare in UnityEngine.RectTransformUtility
bool w_boS_r4r4_oPS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_oPS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_r4r4r4_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
        p3 = &up3;
    }
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, Il2CppObject* p3, struct S_r4r4r4_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret3;
    if (p3 == &up3)
    {
        ret3 = DataTransfer::CopyValueType(apis, env, *p3, TIp3);    
        apis->update_boxed_value(env, _sv3, ret3);
    }
    else
    {
        ret3 = apis->native_object_to_value(env, TIp3, p3, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean RectangleContainsScreenPoint(UnityEngine.RectTransform, UnityEngine.Vector2, UnityEngine.Camera, UnityEngine.Vector4) declare in UnityEngine.RectTransformUtility
bool w_boS_r4r4_oS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boS_r4r4_oS_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, Il2CppObject* p3, struct S_r4r4r4r4_ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean op_Equality(GCloud.ConnectorResult, GCloud.ConnectorErrorCode) declare in GCloud.ConnectorResult
bool w_boi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean removeListener(UnityEngine.GameObject, Int32, System.Action`1[LTEvent]) declare in LeanTween
bool w_boi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boi4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, int32_t p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean op_Equality(System.Type, System.Type) declare in System.Type
bool w_boo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryCreate(System.Uri, System.Uri, System.Uri ByRef) declare in System.Uri
bool w_booPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_booPo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
             // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret2 = CSRefToLuaValue(apis, env, TIp2, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsDefined(System.Reflection.MemberInfo, System.Type, Boolean) declare in System.Attribute
bool w_boob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boob");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean FingersMovedInOppositeDirections(Finger, Finger, Single) declare in FingerGesture
bool w_boor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boor4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetReplaceEquipItems(System.Collections.Generic.List`1[SGW+stEquipItem], System.Collections.Generic.List`1[Assets.Scripts.UI.InTheGame.Common.UIEquipCommonItem+EquipWithActor], UInt32) declare in Assets.Scripts.GameLogic.EquipUtil
bool w_boou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_boou4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, uint32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsScreenPosInRect(UnityEngine.RectTransform, Single, Single) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_bor4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bor4r4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, float p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsScreenPosInTrapezoid(UnityEngine.RectTransform, Single, Single, Single, UnityEngine.Vector2) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_bor4r4r4S_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bor4r4r4S_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
             // LuaValToCSVal struct
    S_r4r4_* pp4 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv4);
    S_r4r4_ p4 = pp4 ? *pp4 : S_r4r4_ {};
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, float p2, float p3, float p4, struct S_r4r4_ p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CompareName(UnityEngine.Object, System.String) declare in UnityEngine.Object
bool w_bos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bos");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryParse(System.Type, System.String, System.Object ByRef) declare in System.Enum
bool w_bosPO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bosPO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret2 = CSRefToLuaValue(apis, env, TIp2, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryCreate(System.Uri, System.String, System.Uri ByRef) declare in System.Uri
bool w_bosPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bosPo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);     // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppObject** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret2 = CSRefToLuaValue(apis, env, TIp2, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryParse(System.Type, System.String, Boolean, System.Object ByRef) declare in System.Enum
bool w_bosbPO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bosbPO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
             // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef bool (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, bool p3, Il2CppObject** p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret3 = CSRefToLuaValue(apis, env, TIp3, *p3);
	apis->add_return(info, r);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean OSG_CppCallLua(IntPtr, UInt32, IntPtr, Delegate_OSG_CppCallLua) declare in SGamePInvoke
bool w_bpu4po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bpu4po");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_binary(env, _sv2) && !apis->is_null(env, _sv2) && !apis->is_undefined(env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef bool (*FuncToCall)(void* p1, uint32_t p2, void* p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ToBoolean(Single) declare in System.Convert
bool w_br4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_br4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(float p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Approximately(Single, Single) declare in UnityEngine.Mathf
bool w_br4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_br4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(float p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TheSame(Single, Single, Single, Single) declare in com.pixui.PxMisc
bool w_br4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_br4r4r4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef bool (*FuncToCall)(float p1, float p2, float p3, float p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ToBoolean(Double) declare in System.Convert
bool w_br8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_br8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(double p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CanStreamedLevelBeLoaded(System.String) declare in UnityEngine.Application
bool w_bs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bs");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef bool (*FuncToCall)(Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ContainsResource(System.String, ResourceLoaderStyle) declare in CResourceManager
bool w_bsDi1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsDi1");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef bool (*FuncToCall)(Il2CppString* p1, int8_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryParseHtmlString(System.String, UnityEngine.Color ByRef) declare in UnityEngine.ColorUtility
bool w_bsPS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal Pstruct
    S_r4r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4r4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryParse(System.String, System.DateTime ByRef) declare in System.DateTime
bool w_bsPS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal Pstruct
    S_u8_* p1 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u8_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, struct S_u8_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetBigFileVerifyMd5(System.String, System.String ByRef) declare in Utility
bool w_bsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsPs");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = converter::Converter<Il2CppString*>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryFromBase64String(System.String, System.Span`1[System.Byte], Int32 ByRef) declare in System.Convert
bool w_bsS_S_p_i4_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_S_p_i4_Pi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
             
    // LuaValToCSVal P primitive
    int32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef bool (*FuncToCall)(Il2CppString* p1, struct S_S_p_i4_ p2, int32_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret2 = converter::Converter<int32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean SetVector2(System.String, UnityEngine.Vector2) declare in PlayerPrefsX
bool w_bsS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
        
    typedef bool (*FuncToCall)(Il2CppString* p1, struct S_r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean SetVector3(System.String, UnityEngine.Vector3) declare in PlayerPrefsX
bool w_bsS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef bool (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean SetQuaternion(System.String, UnityEngine.Quaternion) declare in PlayerPrefsX
bool w_bsS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsS_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4r4_ p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean SetBool(System.String, Boolean) declare in PlayerPrefsX
bool w_bsb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsb");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(Il2CppString* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsHexEncoding(System.String, Int32) declare in System.Uri
bool w_bsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsValidLog(System.String, Type, Boolean ByRef) declare in Assets.Plugins.Common.LogTags
bool w_bsi4Pb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4Pb");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal P primitive
    bool up2 = false;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<bool>>::toCpp(apis, env, _sv2);
    bool* p2 = &up2;

    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, bool* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret2 = converter::Converter<bool>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryCreate(System.String, System.UriKind, System.Uri ByRef) declare in System.Uri
bool w_bsi4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsi4Po");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
             // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret2 = CSRefToLuaValue(apis, env, TIp2, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean WriteFile(System.String, Byte[]) declare in Utility
bool w_bso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bso");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryParse(System.String, System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef) declare in System.DateTime
bool w_bsoi4PS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsoi4PS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
             
    // LuaValToCSVal Pstruct
    S_u8_* p3 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_u8_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
        p3 = &up3;
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, struct S_u8_* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret3;
    if (p3 == &up3)
    {
        ret3 = DataTransfer::CopyValueType(apis, env, *p3, TIp3);    
        apis->update_boxed_value(env, _sv3, ret3);
    }
    else
    {
        ret3 = apis->native_object_to_value(env, TIp3, p3, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean WriteFile(System.String, Byte[], Int32, Int32) declare in CFileManager
bool w_bsoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsoi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ClearDirectory(System.String, System.String[], System.String[]) declare in CFileManager
bool w_bsoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsoo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryParseExact(System.String, System.String[], System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef) declare in System.DateTime
bool w_bsooi4PS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bsooi4PS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!apis->is_object(env, _sv4)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
             
    // LuaValToCSVal Pstruct
    S_u8_* p4 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_u8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
        p4 = &up4;
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, int32_t p4, struct S_u8_* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret4;
    if (p4 == &up4)
    {
        ret4 = DataTransfer::CopyValueType(apis, env, *p4, TIp4);    
        apis->update_boxed_value(env, _sv4, ret4);
    }
    else
    {
        ret4 = apis->native_object_to_value(env, TIp4, p4, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Equals(System.String, System.String) declare in System.String
bool w_bss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bss");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CopyDirectory(System.String, System.String, System.String[], Boolean) declare in CFileManager
bool w_bssDoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssDoDb");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2); // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, bool p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Equals(System.String, System.String, System.StringComparison) declare in System.String
bool w_bssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsMatch(System.String, System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan) declare in System.Text.RegularExpressions.Regex
bool w_bssi4S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssi4S_i8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
             // LuaValToCSVal struct
    S_i8_* pp3 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv3);
    S_i8_ p3 = pp3 ? *pp3 : S_i8_ {};
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, struct S_i8_ p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean PictureCombine(System.String, System.String, enCombinePosition, Boolean, Boolean) declare in Utility
bool w_bssi4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssi4bb");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, bool p4, bool p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryParseExact(System.String, System.String, System.IFormatProvider, System.Globalization.DateTimeStyles, System.DateTime ByRef) declare in System.DateTime
bool w_bssoi4PS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bssoi4PS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!apis->is_object(env, _sv4)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
             
    // LuaValToCSVal Pstruct
    S_u8_* p4 = DataTransfer::GetPointer<S_u8_>(apis, env, apis->unboxing(env, _sv4)); // valuetype ref
    S_u8_ up4;
    if (!p4) {
        memset(&up4, 0, sizeof(p4));
        p4 = &up4;
    }
        
    typedef bool (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, struct S_u8_* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret4;
    if (p4 == &up4)
    {
        ret4 = DataTransfer::CopyValueType(apis, env, *p4, TIp4);    
        apis->update_boxed_value(env, _sv4, ret4);
    }
    else
    {
        ret4 = apis->native_object_to_value(env, TIp4, p4, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsValid(Single) declare in com.pixui.PxMisc
bool w_bt(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bt");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef bool (*FuncToCall)(void*,const void* method);
    bool ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Unload(Boolean) declare in CResource
bool w_btDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btDb");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef bool (*FuncToCall)(void*,bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetPrefabVisible(Int32) declare in UIPrefabBase
bool w_btDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btDi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef bool (*FuncToCall)(void*,int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ScrollToBottom(Single) declare in Timi.TimiListView
bool w_btDr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btDr4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    float p0 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef bool (*FuncToCall)(void*,float p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsEnumDefined(System.Object) declare in System.Type
bool w_btO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsKeywordEnabled(UnityEngine.Rendering.LocalKeyword ByRef) declare in UnityEngine.Material
bool w_btPS_S_p_su4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_S_p_su4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_S_p_su4_* p0 = DataTransfer::GetPointer<S_S_p_su4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_S_p_su4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_su4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryGetCullingParameters(UnityEngine.Rendering.ScriptableCullingParameters ByRef) declare in UnityEngine.Camera
bool w_btPS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* p0 = DataTransfer::GetPointer<S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef bool (*FuncToCall)(void*,struct S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CheckIfGainNewEquip(Project8EquipItems ByRef) declare in Assets.Scripts.GameLogic.Project8Equipment
bool w_btPS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_o_* p0 = DataTransfer::GetPointer<S_o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef bool (*FuncToCall)(void*,struct S_o_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean NtfHeroesInBattleChanged(BattleAreaInfo ByRef, UInt32) declare in Assets.Scripts.GameLogic.PlayerChessManager
bool w_btPS_ooooi4i4_u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_ooooi4i4_u4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_ooooi4i4_* p0 = DataTransfer::GetPointer<S_ooooi4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_ooooi4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,struct S_ooooi4i4_* p1, uint32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsPosInSellArea(UnityEngine.Vector3 ByRef) declare in Assets.Scripts.GameLogic.Project8SceneManagement
bool w_btPS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_r4r4r4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetAndroidMemoryInfo(Int32 ByRef, Int32 ByRef, Int32 ByRef, Int32 ByRef) declare in SystemSetting
bool w_btPi4Pi4Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPi4Pi4Pi4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
     
    // LuaValToCSVal P primitive
    int32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
     
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
     
    // LuaValToCSVal P primitive
    int32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;
     
    // LuaValToCSVal P primitive
    int32_t up3 = 0;
    if (3 < lua_args_len)
        up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv3);
    int32_t* p3 = &up3;

    typedef bool (*FuncToCall)(void*,int32_t* p1, int32_t* p2, int32_t* p3, int32_t* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret0 = converter::Converter<int32_t>::toScript(apis, env, *p0);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	int ret2 = converter::Converter<int32_t>::toScript(apis, env, *p2);
	int ret3 = converter::Converter<int32_t>::toScript(apis, env, *p3);
	apis->add_return(info, r);
	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CollectAssociateAssets(System.Collections.Generic.List`1[Assets.Scripts.Framework.AssetService.AssetData] ByRef, System.Collections.Generic.Dictionary`2[System.String,System.Boolean] ByRef) declare in Assets.Scripts.Framework.AssetService.InstantiatableAsset
bool w_btPoPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btPoPo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     // LuaValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ret
    Il2CppObject** p0 = &up0;
             // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef bool (*FuncToCall)(void*,Il2CppObject** p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret0 = CSRefToLuaValue(apis, env, TIp0, *p0);
	int ret1 = CSRefToLuaValue(apis, env, TIp1, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Equals(System.ReadOnlySpan`1[System.Char]) declare in System.Text.StringBuilder
bool w_btS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryFormat(System.Span`1[System.Char], Int32 ByRef, System.ReadOnlySpan`1[System.Char], System.IFormatProvider) declare in System.DateTime
bool w_btS_S_p_i4_Pi4DS_S_p_i4_Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_p_i4_Pi4DS_S_p_i4_Do");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (lua_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
             
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
    // LuaValToCSVal valuetype with default
    S_S_p_i4_ p2 = OptionalParameter<S_S_p_i4_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 2);
                // LuaValToCSVal ref with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 3, TIp3);
    typedef bool (*FuncToCall)(void*,struct S_S_p_i4_ p1, int32_t* p2, struct S_S_p_i4_ p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Equals(UnityEngine.Bounds) declare in UnityEngine.Bounds
bool w_btS_S_r4r4r4_S_r4r4r4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4r4r4_S_r4r4r4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
        
    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4__ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IntersectRay(UnityEngine.Ray, Single ByRef) declare in UnityEngine.Bounds
bool w_btS_S_r4r4r4_S_r4r4r4__Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_S_r4r4r4_S_r4r4r4__Pr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     // LuaValToCSVal struct
    S_S_r4r4r4_S_r4r4r4__* pp0 = DataTransfer::GetPointer<S_S_r4r4r4_S_r4r4r4__>(apis, env, _sv0);
    S_S_r4r4r4_S_r4r4r4__ p0 = pp0 ? *pp0 : S_S_r4r4r4_S_r4r4r4__ {};
             
    // LuaValToCSVal P primitive
    float up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv1);
    float* p1 = &up1;

    typedef bool (*FuncToCall)(void*,struct S_S_r4r4r4_S_r4r4r4__ p1, float* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = converter::Converter<float>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean OnNBHeroDragBegin(VInt2, VInt2, Boolean, Boolean, Boolean, Boolean, UInt32 ByRef) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_btS_i4i4_S_i4i4_bbbbPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i4i4_S_i4i4_bbbbPu4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;
        if (!apis->is_object(env, _sv6)) return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
             
    // LuaValToCSVal P primitive
    uint32_t up6 = 0;
    if (6 < lua_args_len)
        up6 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv6);
    uint32_t* p6 = &up6;

    typedef bool (*FuncToCall)(void*,struct S_i4i4_ p1, struct S_i4i4_ p2, bool p3, bool p4, bool p5, bool p6, uint32_t* p7, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret6 = converter::Converter<uint32_t>::toScript(apis, env, *p6);
	apis->add_return(info, r);
	apis->add_return(info, ret6);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsInPlayTime(System.TimeSpan, System.String, System.String) declare in Assets.Scripts.Sound.PlayBroadcastManager
bool w_btS_i8_ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_i8_ss");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_i8_* pp0 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv0);
    S_i8_ p0 = pp0 ? *pp0 : S_i8_ {};
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef bool (*FuncToCall)(void*,struct S_i8_ p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Equals(UnityEngine.Vector2) declare in UnityEngine.Vector2
bool w_btS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsRaycastLocationValid(UnityEngine.Vector2, UnityEngine.Camera) declare in UIEventListener
bool w_btS_r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4_o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4_ p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Equals(UnityEngine.Vector3) declare in UnityEngine.Vector3
bool w_btS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Contains(UnityEngine.Vector3, Boolean) declare in UnityEngine.Rect
bool w_btS_r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4_b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4_ p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Equals(UnityEngine.Quaternion) declare in UnityEngine.Quaternion
bool w_btS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Overlaps(UnityEngine.Rect, Boolean) declare in UnityEngine.Rect
bool w_btS_r4r4r4r4_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_r4r4r4r4_b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsSame(Assets.Scripts.GameSystem.CullData) declare in Assets.Scripts.GameSystem.CullData
bool w_btS_u4bbbi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u4bbbi4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4bbbi4_* pp0 = DataTransfer::GetPointer<S_u4bbbi4_>(apis, env, _sv0);
    S_u4bbbi4_ p0 = pp0 ? *pp0 : S_u4bbbi4_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u4bbbi4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Equals(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]) declare in PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]
bool w_btS_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u4o_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ShowAllWearItem(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker], UInt32, UInt32) declare in Assets.Scripts.UI.InTheGame.Standard.UIEquip
bool w_btS_u4o_u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u4o_u4u4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef bool (*FuncToCall)(void*,struct S_u4o_ p1, uint32_t p2, uint32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Equals(System.DateTime) declare in System.DateTime
bool w_btS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef bool (*FuncToCall)(void*,struct S_u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ExtSetActive(UnityEngine.Component, Boolean) declare in ExtComponent
bool w_btb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btb");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(void*,bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean LuaSetVisible(Boolean, Int32) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_btbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btbDi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef bool (*FuncToCall)(void*,bool p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryGetCullingParameters(Boolean, UnityEngine.Rendering.ScriptableCullingParameters ByRef) declare in UnityEngine.Camera
bool w_btbPS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btbPS_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal Pstruct
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* p1 = DataTransfer::GetPointer<S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef bool (*FuncToCall)(void*,bool p1, struct S_i4S_i4S_r4r4r4_r4r4i4_S_u1_i4u4u8u8bS_r4_i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_r4r4i4i4S_S_r4r4r4r4_S_r4r4r4_r4r4r4r4r4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_S_r4r4r4_r4u4S_u1_S_u1_r4S_r4r4r4_S_r4_i4S_i4u4i4_u4i4i4_r4i4S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_S_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4i4bi4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean DynamicInvoke(Boolean, System.Object[]) declare in Assets.Scripts.GameSystem.MuteLayerPopupBase
bool w_btbVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btbVO");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
            // LuaValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef bool (*FuncToCall)(void*,bool p1, Il2CppArray* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean SetVisible(Boolean, PrefabVisibleMask) declare in UIPrefabBase
bool w_btbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btbi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,bool p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean EndsWith(Char) declare in System.String
bool w_btc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btc");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(void*,Il2CppChar p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Contains(Char, System.StringComparison) declare in System.String
bool w_btci4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btci4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean HasTransformConfig(Assets.Scripts.GameLogic.ETransformConfigUsage) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_bti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(void*,int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CheckCurrencyEnough(ResData.CountableAssetType, Int32) declare in Assets.Scripts.GameLogic.PlayerCaptainControl
bool w_bti4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4Di4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef bool (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ScrollToCenter(Int32, Single) declare in Timi.TimiListView
bool w_bti4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4Dr4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef bool (*FuncToCall)(void*,int32_t p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ScrollTo(Int32, Single, Single) declare in Timi.TimiListView
bool w_bti4Dr4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4Dr4Dr4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef bool (*FuncToCall)(void*,int32_t p1, float p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetHeroCoordByCfgId(Int32, VInt2 ByRef) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_bti4PS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4PS_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal Pstruct
    S_i4i4_* p1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef bool (*FuncToCall)(void*,int32_t p1, struct S_i4i4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetLastCharVertScreenPos(UnityEngine.TextAnchor, UnityEngine.Vector3 ByRef) declare in Timi.TimiText
bool w_bti4PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4PS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef bool (*FuncToCall)(void*,int32_t p1, struct S_r4r4r4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryGetSkillContext(OSProto.LordSkillSlotID, Project8CastLordSkillContext ByRef) declare in Assets.Scripts.UI.InGameCommon.UILordSkillDataItem
bool w_bti4PS_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4PS_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_* p1 = DataTransfer::GetPointer<S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef bool (*FuncToCall)(void*,int32_t p1, struct S_u4u4u4u4u4u4u4u4u4S_u1u4u4_ou4u4u4u4si4i4i4su4o_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Remove(ResData.ActorAbilitySymmetryType, Int32 ByRef) declare in System.Collections.Generic.Dictionary`2[ResData.ActorAbilitySymmetryType,System.Int32]
bool w_bti4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef bool (*FuncToCall)(void*,int32_t p1, int32_t* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Remove(Int32, Lord_SkillInfo ByRef) declare in System.Collections.Generic.Dictionary`2[System.Int32,OSProto.IN_GAME_PRESENTATION_DATA+Lord_SkillInfo]
bool w_bti4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4Po");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef bool (*FuncToCall)(void*,int32_t p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = CSRefToLuaValue(apis, env, TIp1, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean FindTextureStack(Int32, System.String ByRef, Int32 ByRef) declare in UnityEngine.Shader
bool w_bti4PsPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4PsPi4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
             
    // LuaValToCSVal P primitive
    int32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef bool (*FuncToCall)(void*,int32_t p1, Il2CppString** p2, int32_t* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = converter::Converter<Il2CppString*>::toScript(apis, env, *p1);
	int ret2 = converter::Converter<int32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetEquipListItemInfo(Int32, UInt32 ByRef, System.String ByRef) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_bti4Pu4Ps(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4Pu4Ps");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;
     // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,int32_t p1, uint32_t* p2, Il2CppString** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	int ret2 = converter::Converter<Il2CppString*>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean OnNBCardDragBegin(Int32, VInt2, Boolean, Boolean, Int32, UInt32 ByRef) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_bti4S_i4i4_bbi4Pu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4S_i4i4_bbi4Pu4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!apis->is_object(env, _sv5)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
             
    // LuaValToCSVal P primitive
    uint32_t up5 = 0;
    if (5 < lua_args_len)
        up5 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv5);
    uint32_t* p5 = &up5;

    typedef bool (*FuncToCall)(void*,int32_t p1, struct S_i4i4_ p2, bool p3, bool p4, int32_t p5, uint32_t* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret5 = converter::Converter<uint32_t>::toScript(apis, env, *p5);
	apis->add_return(info, r);
	apis->add_return(info, ret5);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean HandleForbiddenClick(Assets.Scripts.GameSystem.NBForbidUIClickType, Boolean) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_bti4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,int32_t p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean SetVisibleByMultiMask(Int32, Boolean, Int32, Boolean) declare in UIPrefabBase
bool w_bti4bi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4bi4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef bool (*FuncToCall)(void*,int32_t p1, bool p2, int32_t p3, bool p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean HasRelation(ResData.RES_RELATION_ID, ResData.ActorRelationType) declare in Assets.Scripts.GameLogic.ActorExtraDataLinkerComponent
bool w_bti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryAdd(Int32, Lord_SkillInfo) declare in System.Collections.Generic.Dictionary`2[System.Int32,OSProto.IN_GAME_PRESENTATION_DATA+Lord_SkillInfo]
bool w_bti4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4o");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean DoesFucMaskTypeFitToGrid(Int32, UInt32) declare in Assets.Scripts.GameLogic.CEquipContainer
bool w_bti4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,int32_t p1, uint32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean OnNBDragEquipBegin(Assets.Scripts.GameSystem.NewbieEquipDragOpType, UInt32, UInt32, UInt32, Boolean, UInt32 ByRef) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_bti4u4u4u4bPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti4u4u4u4bPu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!apis->is_object(env, _sv5)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
             
    // LuaValToCSVal P primitive
    uint32_t up5 = 0;
    if (5 < lua_args_len)
        up5 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv5);
    uint32_t* p5 = &up5;

    typedef bool (*FuncToCall)(void*,int32_t p1, uint32_t p2, uint32_t p3, uint32_t p4, bool p5, uint32_t* p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret5 = converter::Converter<uint32_t>::toScript(apis, env, *p5);
	apis->add_return(info, r);
	apis->add_return(info, ret5);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsReady(Int64) declare in Assets.Scripts.Resource.Package.QtsPackageManager
bool w_bti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bti8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(void*,int64_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ExtIsChildOf(UnityEngine.Transform, UnityEngine.Transform) declare in ExtTransform
bool w_bto(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bto");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean RegisterPopupLayerDelegate(Assets.Scripts.GameSystem.MuteLayerPopupBase, System.Object) declare in Assets.Scripts.GameSystem.MuteBase
bool w_btoO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryGetComponent(System.Type, UnityEngine.Component ByRef) declare in UnityEngine.Component
bool w_btoPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoPo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = CSRefToLuaValue(apis, env, TIp1, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CheckForbidden(ResData.ResEquipDataBin, System.String ByRef) declare in Assets.Scripts.GameLogic.EquipLinkerComponent
bool w_btoPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoPs");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = converter::Converter<Il2CppString*>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsPosInSellArea(Assets.Scripts.GameLogic.Project8PlayerInstance, UnityEngine.Vector2, ResData.RES_PROJECT8_DROP_ITEM_TYPE) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_btoS_r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoS_r4r4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, struct S_r4r4_ p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean LoadImage(UnityEngine.Texture2D, Byte[], Boolean) declare in UnityEngine.ImageConversion
bool w_btob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btob");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean SetPopupLayerVisible(Assets.Scripts.GameSystem.MuteLayerPopupBase, Boolean, Boolean, System.Object) declare in Assets.Scripts.GameSystem.MuteBase
bool w_btobbO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btobbO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, bool p2, bool p3, Il2CppObject* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean RenderToCubemap(UnityEngine.Cubemap, Int32) declare in UnityEngine.Camera
bool w_btoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean RenderToCubemap(UnityEngine.RenderTexture, Int32, MonoOrStereoscopicEye) declare in UnityEngine.Camera
bool w_btoi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean AddEvent(UIEventID, GenericDelegate) declare in Assets.Scripts.Framework.UI.UIPrefabBaseClass
bool w_btoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean RigisterGameObject(UnityEngine.GameObject, Assets.Scripts.Framework.AssetService.InstantiatableAsset, UInt32) declare in UnityObjMgr
bool w_btoou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btoou4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, uint32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ShowSingleWearItem(ResData.ResEquipDataBin, UInt32, UInt32) declare in Assets.Scripts.UI.InTheGame.Standard.UIEquip
bool w_btou4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btou4Du4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    uint32_t p2 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, uint32_t p2, uint32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CheckCanEquip(ResData.ResEquipDataBin, UInt32, System.String ByRef) declare in Assets.Scripts.GameLogic.PlayerRelation
bool w_btou4Ps(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btou4Ps");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
             // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,Il2CppObject* p1, uint32_t p2, Il2CppString** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret2 = converter::Converter<Il2CppString*>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean SetScrollValue(Single, Single) declare in Timi.TimiListView
bool w_btr4Dr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btr4Dr4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef bool (*FuncToCall)(void*,float p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ExtSetText(UnityEngine.UI.Text, System.String) declare in ExtText
bool w_bts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bts");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsNameEquals(System.String, Boolean) declare in UnityEngine.Object
bool w_btsDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsDb");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean AddToPlayList(System.String, SetMode) declare in MultifunctionRawImage
bool w_btsDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsDi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean AddToPlayList(System.String, SetMode, Boolean) declare in CriManaProxy`1[CriWare.CriManaMovieController]
bool w_btsDi4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsDi4Db");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetSceneItemPos(System.String, UnityEngine.Vector3 ByRef) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_btsPS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, struct S_r4r4r4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CheckDependencyDisconnectedAsset(System.String, DepDisconnectedAssetInfoRuntimeData ByRef) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_btsPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = CSRefToLuaValue(apis, env, TIp1, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Remove(System.String, System.String ByRef) declare in System.Collections.Generic.Dictionary`2[System.String,System.String]
bool w_btsPs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsPs");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppString** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = converter::Converter<Il2CppString*>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean EndsWith(System.String, Boolean, System.Globalization.CultureInfo) declare in System.String
bool w_btsbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsbo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, bool p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Play(System.String, UnityEngine.PlayMode) declare in UnityEngine.Animation
bool w_btsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Hit(System.String, Effect.EffectLoadInfo[]) declare in Effect.EffectLODAdaptor
bool w_btso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btso");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean EffectTrigger(System.String, UnityEngine.Events.UnityAction, System.String) declare in Timi.TimiUserInterfaceEffects
bool w_btsoDs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsoDs");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal string with default
    Il2CppString* p2 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 2);
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean TryAdd(System.String, System.String) declare in System.Collections.Generic.Dictionary`2[System.String,System.String]
bool w_btss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btss");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean Load(System.String, System.String, Boolean, System.Action, Int32, Int32) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_btssboDi4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btssboDi4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
         // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
             // LuaValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, bool p3, Il2CppObject* p4, int32_t p5, int32_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean SwitchBgm(System.String, System.String, System.String, System.String) declare in Assets.Scripts.Sound.BgmSwitcher
bool w_btssss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btssss");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, Il2CppString* p2, Il2CppString* p3, Il2CppString* p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetRewardCardItemGo(System.String, UInt32, UnityEngine.GameObject ByRef) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_btsu4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btsu4Po");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
             // LuaValToCSVal Po/PO
    Il2CppObject* up2 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv2)); // object ret
    Il2CppObject** p2 = &up2;
        
    typedef bool (*FuncToCall)(void*,Il2CppString* p1, uint32_t p2, Il2CppObject** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret2 = CSRefToLuaValue(apis, env, TIp2, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsInPhaseType(Byte) declare in Assets.Scripts.GameLogic.Project8RoundStateFlow
bool w_btu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(void*,uint8_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean HasSameEquip(UInt16) declare in Assets.Scripts.GameLogic.CEquipContainer
bool w_btu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(void*,uint16_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean HasEquip(UInt16, Int32) declare in Assets.Scripts.GameLogic.CEquipContainer
bool w_btu2Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu2Di4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef bool (*FuncToCall)(void*,uint16_t p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetProductRecipe(UInt16, Assets.Scripts.GameSystem.EquipRecipe ByRef) declare in Assets.Scripts.GameSystem.Project8EquipmentRecipe
bool w_btu2PS_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu2PS_u4u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal Pstruct
    S_u4u4u4_* p1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u4u4u4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef bool (*FuncToCall)(void*,uint16_t p1, struct S_u4u4u4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean SetKeyFrameIndex(UInt32) declare in Assets.Scripts.Framework.FrameSynchr
bool w_btu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsHeroExtraGridFull(UInt32, Boolean, UInt32) declare in Assets.Scripts.GameLogic.EquipLinkerComponent
bool w_btu4DbDu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4DbDu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
             // LuaValToCSVal primitive with default
    uint32_t p2 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef bool (*FuncToCall)(void*,uint32_t p1, bool p2, uint32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetEquipItemPos(UInt32, UnityEngine.Vector3 ByRef) declare in Assets.Scripts.UI.InTheGame.Standard.UIEquip
bool w_btu4PS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4PS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, struct S_r4r4r4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetSkinPrefab(UInt32, Assets.Scripts.GameLogic.SkinElement ByRef) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_btu4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4Po");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, Il2CppObject** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = CSRefToLuaValue(apis, env, TIp1, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetBroadcastAudio(UInt32, System.String ByRef) declare in Assets.Scripts.GameLogic.PlayerBattleBroadcast
bool w_btu4Ps(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4Ps");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, Il2CppString** p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = converter::Converter<Il2CppString*>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetDropIdByRound(UInt32, UInt32 ByRef) declare in Assets.Scripts.GameLogic.Project8AirdropAwardLogic
bool w_btu4Pu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4Pu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;

    typedef bool (*FuncToCall)(void*,uint32_t p1, uint32_t* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsNewAddEquip(UInt32, Boolean) declare in Assets.Scripts.GameLogic.Project8Equipment
bool w_btu4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean HasNewCardFly(UInt32, OSProto.InteractiveEffectType) declare in Assets.Scripts.GameSystem.UIComponentArtEffect
bool w_btu4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetHandCardItemPath(UInt32, Int32, UInt32, System.String ByRef) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_btu4i4u4Ps(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4i4u4Ps");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
             // LuaValToCSVal Ps
    Il2CppString* up3 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv3); // string ref
    Il2CppString** p3 = &up3;
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, int32_t p2, uint32_t p3, Il2CppString** p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret3 = converter::Converter<Il2CppString*>::toScript(apis, env, *p3);
	apis->add_return(info, r);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsActorHasRelation(UInt32, ResData.ResChessHeroConfDataBin, Int32) declare in Assets.Scripts.GameLogic.PlayerChessManager
bool w_btu4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4oi4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, Il2CppObject* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ReplaceGameObject(UInt32, UnityEngine.GameObject, Assets.Scripts.Framework.AssetService.InstantiatableAsset) declare in UnityObjMgr
bool w_btu4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4oo");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsEnoughMoney(UInt32, UInt32) declare in Assets.Scripts.GameLogic.PlayerCaptainControl
bool w_btu4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, uint32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean WhetherShowParticle(UInt32, UInt32, Boolean, Boolean) declare in Assets.Scripts.GameSystem.LogicComponentPerformance
bool w_btu4u4bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4u4bb");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, uint32_t p2, bool p3, bool p4, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean OnDragStart(UInt32, UInt32, UInt32) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_btu4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_btu4u4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef bool (*FuncToCall)(void*,uint32_t p1, uint32_t p2, uint32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ToBoolean(Byte) declare in System.Convert
bool w_bu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(uint8_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ToBoolean(UInt16) declare in System.Convert
bool w_bu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(uint16_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ToBoolean(UInt32) declare in System.Convert
bool w_bu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(uint32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CanTakeOffEquip(UInt32, Boolean) declare in Assets.Scripts.GameLogic.EquipUtil
bool w_bu4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu4Db");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef bool (*FuncToCall)(uint32_t p1, bool p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsHostView(UInt32, PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker] ByRef) declare in Assets.Scripts.GameLogic.ActorHelper
bool w_bu4PS_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu4PS_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal Pstruct
    S_u4o_* p1 = DataTransfer::GetPointer<S_u4o_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef bool (*FuncToCall)(uint32_t p1, struct S_u4o_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CheckMask(UInt32, Int32) declare in Utility
bool w_bu4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(uint32_t p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean HasData(UInt32, Int32, OSProto.SyncDynamicDesc) declare in Assets.Scripts.UI.InTheGame.Standard.UICardMetaTipsPop
bool w_bu4i4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu4i4Do");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef bool (*FuncToCall)(uint32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean IsProject8SameTypeHero(UInt32, UInt32) declare in Assets.Scripts.GameLogic.ActorHelper
bool w_bu4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef bool (*FuncToCall)(uint32_t p1, uint32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean CanTakeOffEquip(UInt32, UInt32, Boolean) declare in Assets.Scripts.GameLogic.EquipUtil
bool w_bu4u4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu4u4Db");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef bool (*FuncToCall)(uint32_t p1, uint32_t p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean GetChessHeroComposeSound2(UInt32, UInt32, System.String ByRef) declare in PBData.PBDataAux
bool w_bu4u4Ps(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu4u4Ps");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
             // LuaValToCSVal Ps
    Il2CppString* up2 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv2); // string ref
    Il2CppString** p2 = &up2;
        
    typedef bool (*FuncToCall)(uint32_t p1, uint32_t p2, Il2CppString** p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	int ret2 = converter::Converter<Il2CppString*>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean ToBoolean(UInt64) declare in System.Convert
bool w_bu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_bu8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef bool (*FuncToCall)(uint64_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<bool>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(System.Object) declare in System.Convert
bool w_cO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef Il2CppChar (*FuncToCall)(Il2CppObject* p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(System.Object, System.IFormatProvider) declare in System.Convert
bool w_cOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cOo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppChar (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(System.Decimal) declare in System.Convert
bool w_cS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cS_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef Il2CppChar (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(System.DateTime) declare in System.Convert
bool w_cS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef Il2CppChar (*FuncToCall)(struct S_u8_ p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(Boolean) declare in System.Convert
bool w_cb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cb");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef Il2CppChar (*FuncToCall)(bool p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(Char) declare in System.Convert
bool w_cc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cc");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef Il2CppChar (*FuncToCall)(Il2CppChar p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(SByte) declare in System.Convert
bool w_ci1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ci1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppChar (*FuncToCall)(int8_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(Int16) declare in System.Convert
bool w_ci2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ci2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppChar (*FuncToCall)(int16_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(Int32) declare in System.Convert
bool w_ci4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ci4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppChar (*FuncToCall)(int32_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(Int64) declare in System.Convert
bool w_ci8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ci8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppChar (*FuncToCall)(int64_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(Single) declare in System.Convert
bool w_cr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cr4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef Il2CppChar (*FuncToCall)(float p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(Double) declare in System.Convert
bool w_cr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cr8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef Il2CppChar (*FuncToCall)(double p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(System.String) declare in System.Convert
bool w_cs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cs");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef Il2CppChar (*FuncToCall)(Il2CppString* p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char HexUnescape(System.String, Int32 ByRef) declare in System.Uri
bool w_csPi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_csPi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef Il2CppChar (*FuncToCall)(Il2CppString* p1, int32_t* p2, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(System.String, System.IFormatProvider) declare in System.Convert
bool w_cso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cso");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppChar (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char get_asteriskChar() declare in UnityEngine.UI.InputField
bool w_ct(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ct");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef Il2CppChar (*FuncToCall)(void*,const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char get_Chars(Int32) declare in System.String
bool w_cti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cti4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppChar (*FuncToCall)(void*,int32_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(Byte) declare in System.Convert
bool w_cu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cu1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppChar (*FuncToCall)(uint8_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(UInt16) declare in System.Convert
bool w_cu2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cu2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppChar (*FuncToCall)(uint16_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(UInt32) declare in System.Convert
bool w_cu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppChar (*FuncToCall)(uint32_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char ToChar(UInt64) declare in System.Convert
bool w_cu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_cu8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppChar (*FuncToCall)(uint64_t p1, const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<Il2CppChar>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(System.Object) declare in System.Convert
bool w_i1O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef int8_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(System.Object, System.IFormatProvider) declare in System.Convert
bool w_i1Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef int8_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(System.Decimal) declare in System.Convert
bool w_i1S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef int8_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(System.DateTime) declare in System.Convert
bool w_i1S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef int8_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(Boolean) declare in System.Convert
bool w_i1b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef int8_t (*FuncToCall)(bool p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(Char) declare in System.Convert
bool w_i1c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef int8_t (*FuncToCall)(Il2CppChar p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.LifeType GetEffectLifeType(Assets.Scripts.Framework.AssetService.LifeType) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_i1i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef int8_t (*FuncToCall)(int8_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(Int16) declare in System.Convert
bool w_i1i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef int8_t (*FuncToCall)(int16_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(Int32) declare in System.Convert
bool w_i1i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef int8_t (*FuncToCall)(int32_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(Int64) declare in System.Convert
bool w_i1i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef int8_t (*FuncToCall)(int64_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(Single) declare in System.Convert
bool w_i1r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef int8_t (*FuncToCall)(float p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(Double) declare in System.Convert
bool w_i1r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef int8_t (*FuncToCall)(double p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(System.String) declare in System.Convert
bool w_i1s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef int8_t (*FuncToCall)(Il2CppString* p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(System.String, Int32) declare in System.Convert
bool w_i1si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1si4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef int8_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(System.String, System.IFormatProvider) declare in System.Convert
bool w_i1so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef int8_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// enResourceState get_CurState() declare in CResource
bool w_i1t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1t");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef int8_t (*FuncToCall)(void*,const void* method);
    int8_t ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(Byte) declare in System.Convert
bool w_i1u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef int8_t (*FuncToCall)(uint8_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(UInt16) declare in System.Convert
bool w_i1u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef int8_t (*FuncToCall)(uint16_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(UInt32) declare in System.Convert
bool w_i1u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef int8_t (*FuncToCall)(uint32_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SByte ToSByte(UInt64) declare in System.Convert
bool w_i1u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i1u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef int8_t (*FuncToCall)(uint64_t p1, const void* method);
    int8_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int8_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(System.Object) declare in System.Convert
bool w_i2O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef int16_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(System.Object, System.IFormatProvider) declare in System.Convert
bool w_i2Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef int16_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(System.Decimal) declare in System.Convert
bool w_i2S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef int16_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(System.DateTime) declare in System.Convert
bool w_i2S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef int16_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(Boolean) declare in System.Convert
bool w_i2b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef int16_t (*FuncToCall)(bool p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(Char) declare in System.Convert
bool w_i2c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef int16_t (*FuncToCall)(Il2CppChar p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(SByte) declare in System.Convert
bool w_i2i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef int16_t (*FuncToCall)(int8_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(Int16) declare in System.Convert
bool w_i2i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef int16_t (*FuncToCall)(int16_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(Int32) declare in System.Convert
bool w_i2i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef int16_t (*FuncToCall)(int32_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(Int64) declare in System.Convert
bool w_i2i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef int16_t (*FuncToCall)(int64_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(Single) declare in System.Convert
bool w_i2r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef int16_t (*FuncToCall)(float p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(Double) declare in System.Convert
bool w_i2r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef int16_t (*FuncToCall)(double p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(System.String) declare in System.Convert
bool w_i2s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef int16_t (*FuncToCall)(Il2CppString* p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(System.String, Int32) declare in System.Convert
bool w_i2si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2si4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef int16_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(System.String, System.IFormatProvider) declare in System.Convert
bool w_i2so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef int16_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(Byte) declare in System.Convert
bool w_i2u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef int16_t (*FuncToCall)(uint8_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(UInt16) declare in System.Convert
bool w_i2u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef int16_t (*FuncToCall)(uint16_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(UInt32) declare in System.Convert
bool w_i2u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef int16_t (*FuncToCall)(uint32_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int16 ToInt16(UInt64) declare in System.Convert
bool w_i2u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i2u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef int16_t (*FuncToCall)(uint64_t p1, const void* method);
    int16_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int16_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 get_streamedBytes() declare in UnityEngine.Application
bool w_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef int32_t (*FuncToCall)(const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.TypeCode GetTypeCode(System.Object) declare in System.Convert
bool w_i4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(System.Object, System.IFormatProvider) declare in System.Convert
bool w_i4Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetPanningRule(Int32 ByRef) declare in AkSoundEngine
bool w_i4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal P primitive
    int32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;

    typedef int32_t (*FuncToCall)(int32_t* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret0 = converter::Converter<int32_t>::toScript(apis, env, *p0);
	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetPanningRule(Int32 ByRef, UInt64) declare in AkSoundEngine
bool w_i4Pi4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Pi4u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    int32_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv0);
    int32_t* p0 = &up0;
        
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(int32_t* p1, uint64_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret0 = converter::Converter<int32_t>::toScript(apis, env, *p0);
	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 CopyStringBytes(Byte*, Int32, UInt64) declare in SGW
bool w_i4Pu1i4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Pu1i4u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv2))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    uint8_t up0 = 0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<uint8_t>>::toCpp(apis, env, _sv0);
    uint8_t* p0 = &up0;
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint64_t p2 = converter::Converter<uint64_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint8_t* p1, int32_t p2, uint64_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret0 = converter::Converter<uint8_t>::toScript(apis, env, *p0);
	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 op_Implicit(UnityEngine.LayerMask) declare in UnityEngine.LayerMask
bool w_i4S_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4_* pp0 = DataTransfer::GetPointer<S_i4_>(apis, env, _sv0);
    S_i4_ p0 = pp0 ? *pp0 : S_i4_ {};
        
    typedef int32_t (*FuncToCall)(struct S_i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Dot(VInt2, VInt2) declare in VInt2
bool w_i4S_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_i4i4_S_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef int32_t (*FuncToCall)(struct S_i4i4_ p1, struct S_i4i4_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetRenderTextureSupportedMSAASampleCount(UnityEngine.RenderTextureDescriptor) declare in UnityEngine.SystemInfo
bool w_i4S_i4i4i4i4i4i4i4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};
        
    typedef int32_t (*FuncToCall)(struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(System.Decimal) declare in System.Convert
bool w_i4S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef int32_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// SwipeDirection GetSwipeDirection(UnityEngine.Vector3, Single) declare in FingerGesture
bool w_i4S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(struct S_r4r4r4_ p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 CompareActorType(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker], PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]) declare in Assets.Scripts.GameLogic.ActorHelper
bool w_i4S_u4o_S_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_u4o_S_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
             // LuaValToCSVal struct
    S_u4o_* pp1 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv1);
    S_u4o_ p1 = pp1 ? *pp1 : S_u4o_ {};
        
    typedef int32_t (*FuncToCall)(struct S_u4o_ p1, struct S_u4o_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(System.DateTime) declare in System.Convert
bool w_i4S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef int32_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Compare(System.DateTime, System.DateTime) declare in System.DateTime
bool w_i4S_u8_S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4S_u8_S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
             // LuaValToCSVal struct
    S_u8_* pp1 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv1);
    S_u8_ p1 = pp1 ? *pp1 : S_u8_ {};
        
    typedef int32_t (*FuncToCall)(struct S_u8_ p1, struct S_u8_ p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Min(Int32[]) declare in UnityEngine.Mathf
bool w_i4Vi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Vi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        if(lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
     
    // LuaValToCSVal primitive params
    Il2CppArray* p0 = Params<int32_t>::PackPrimitive(apis, env, info, TIp0, lua_args_len, 0);

    typedef int32_t (*FuncToCall)(Il2CppArray* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetMask(System.String[]) declare in UnityEngine.LayerMask
bool w_i4Vs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4Vs");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        if(lua_args_len > 0 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
     // LuaValToCSVal string params
    Il2CppArray* p0 = Params<void*>::PackString(apis, env, info, TIp0, lua_args_len, 0);
            
    typedef int32_t (*FuncToCall)(Il2CppArray* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(Boolean) declare in System.Convert
bool w_i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(bool p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetLevelCustomParam(Boolean, Boolean, Boolean) declare in LuaCallCSharpInteraction
bool w_i4bbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4bbb");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(bool p1, bool p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(Char) declare in System.Convert
bool w_i4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(Il2CppChar p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(SByte) declare in System.Convert
bool w_i4i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(int8_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(Int16) declare in System.Convert
bool w_i4i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(int16_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.StackTraceLogType GetStackTraceLogType(UnityEngine.LogType) declare in UnityEngine.Application
bool w_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetApmInfo(ApmInfoType, Boolean) declare in GCloud.GPM.GPMAgent
bool w_i4i4Db(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4Db");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef int32_t (*FuncToCall)(int32_t p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Experimental.Rendering.GraphicsFormat GetCompatibleFormat(UnityEngine.Experimental.Rendering.GraphicsFormat, UnityEngine.Experimental.Rendering.FormatUsage) declare in UnityEngine.SystemInfo
bool w_i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Clamp(Int32, Int32, Int32) declare in UnityEngine.Mathf
bool w_i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PrepareGameSyncs(AkPreparationType, AkGroupType, System.String, System.String[], UInt32) declare in AkSoundEngine
bool w_i4i4i4sou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4sou4");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, Il2CppString* p3, Il2CppObject* p4, uint32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PrepareGameSyncs(AkPreparationType, AkGroupType, System.String, System.String[], UInt32, BankCallback, System.Object) declare in AkSoundEngine
bool w_i4i4i4sou4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4sou4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, Il2CppString* p3, Il2CppObject* p4, uint32_t p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PostCode(AkMonitorErrorCode, AkMonitorErrorLevel, UInt32) declare in AkSoundEngine
bool w_i4i4i4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, uint32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PostCode(AkMonitorErrorCode, AkMonitorErrorLevel, UInt32, UnityEngine.GameObject) declare in AkSoundEngine
bool w_i4i4i4u4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4u4o");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, uint32_t p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PrepareGameSyncs(AkPreparationType, AkGroupType, UInt32, UInt32[], UInt32) declare in AkSoundEngine
bool w_i4i4i4u4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4u4ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, uint32_t p3, Il2CppObject* p4, uint32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PostCode(AkMonitorErrorCode, AkMonitorErrorLevel, UInt32, UnityEngine.GameObject, UInt32, Boolean) declare in AkSoundEngine
bool w_i4i4i4u4ou4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4u4ou4b");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, uint32_t p3, Il2CppObject* p4, uint32_t p5, bool p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PrepareGameSyncs(AkPreparationType, AkGroupType, UInt32, UInt32[], UInt32, BankCallback, System.Object) declare in AkSoundEngine
bool w_i4i4i4u4ou4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4i4u4ou4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    typedef int32_t (*FuncToCall)(int32_t p1, int32_t p2, uint32_t p3, Il2CppObject* p4, uint32_t p5, Il2CppObject* p6, Il2CppObject* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PrepareEvent(AkPreparationType, System.String[], UInt32) declare in AkSoundEngine
bool w_i4i4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppObject* p2, uint32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PrepareEvent(AkPreparationType, System.String[], UInt32, BankCallback, System.Object) declare in AkSoundEngine
bool w_i4i4ou4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4ou4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PrepareBank(AkPreparationType, System.String) declare in AkSoundEngine
bool w_i4i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4s");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 LoadData(Int32, System.String, com.pixui.NativeBuffer ByRef) declare in com.pixui.PxContext
bool w_i4i4sPS_pi4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4sPS_pi4_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);     
    // LuaValToCSVal Pstruct
    S_pi4_* p2 = DataTransfer::GetPointer<S_pi4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_pi4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
        
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppString* p2, struct S_pi4_* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PrepareBank(AkPreparationType, System.String, AkBankContent) declare in AkSoundEngine
bool w_i4i4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4si4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppString* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PrepareBank(AkPreparationType, System.String, BankCallback, System.Object) declare in AkSoundEngine
bool w_i4i4soO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4soO");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PrepareBank(AkPreparationType, System.String, BankCallback, System.Object, AkBankContent) declare in AkSoundEngine
bool w_i4i4soOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4soOi4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(int32_t p1, Il2CppString* p2, Il2CppObject* p3, Il2CppObject* p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PrepareBank(AkPreparationType, UInt32) declare in AkSoundEngine
bool w_i4i4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(int32_t p1, uint32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PrepareBank(AkPreparationType, UInt32, AkBankContent) declare in AkSoundEngine
bool w_i4i4u4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4u4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(int32_t p1, uint32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PrepareBank(AkPreparationType, UInt32, BankCallback, System.Object) declare in AkSoundEngine
bool w_i4i4u4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4u4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef int32_t (*FuncToCall)(int32_t p1, uint32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PrepareBank(AkPreparationType, UInt32, BankCallback, System.Object, AkBankContent) declare in AkSoundEngine
bool w_i4i4u4oOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4u4oOi4");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(int32_t p1, uint32_t p2, Il2CppObject* p3, Il2CppObject* p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetPanningRule(AkPanningRule, UInt64) declare in AkSoundEngine
bool w_i4i4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i4u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(int32_t p1, uint64_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(Int64) declare in System.Convert
bool w_i4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(int64_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.TypeCode GetTypeCode(System.Type) declare in System.Type
bool w_i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 BinarySearch(System.Array, System.Object) declare in System.Array
bool w_i4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 IndexOf(System.Array, System.Object, Int32) declare in System.Array
bool w_i4oOi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oOi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 IndexOf(System.Array, System.Object, Int32, Int32) declare in System.Array
bool w_i4oOi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oOi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 BinarySearch(System.Array, System.Object, System.Collections.IComparer) declare in System.Array
bool w_i4oOo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oOo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT QueryReflectionPaths(UnityEngine.GameObject, UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef, AkReflectionPathInfoArray, UInt32 ByRef) declare in AkSoundEngine
bool w_i4oPS_r4r4r4_PS_r4r4r4_oPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oPS_r4r4r4_PS_r4r4r4_oPu4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!apis->is_object(env, _sv4)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_r4r4r4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
             
    // LuaValToCSVal Pstruct
    S_r4r4r4_* p2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_r4r4r4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
             
    // LuaValToCSVal P primitive
    uint32_t up4 = 0;
    if (4 < lua_args_len)
        up4 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv4);
    uint32_t* p4 = &up4;

    typedef int32_t (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_* p2, struct S_r4r4r4_* p3, Il2CppObject* p4, uint32_t* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }
                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }

	int ret4 = converter::Converter<uint32_t>::toScript(apis, env, *p4);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetSpeakerAngles(Single[], UInt32 ByRef, Single ByRef) declare in AkSoundEngine
bool w_i4oPu4Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oPu4Pr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;
     
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;

    typedef int32_t (*FuncToCall)(Il2CppObject* p1, uint32_t* p2, float* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetSpeakerAngles(Single[], UInt32 ByRef, Single ByRef, UInt64) declare in AkSoundEngine
bool w_i4oPu4Pr4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oPu4Pr4u8");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;
     
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
        
    // LuaValToCSVal P any
    uint64_t p3 = converter::Converter<uint64_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, uint32_t* p2, float* p3, uint64_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetPlayingIDsFromGameObject(UnityEngine.GameObject, UInt32 ByRef, UInt32[]) declare in AkSoundEngine
bool w_i4oPu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oPu4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, uint32_t* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT AddOutput(AkOutputSettings, UInt64 ByRef) declare in AkSoundEngine
bool w_i4oPu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oPu8");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             
    // LuaValToCSVal P primitive
    uint64_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv1);
    uint64_t* p1 = &up1;

    typedef int32_t (*FuncToCall)(Il2CppObject* p1, uint64_t* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint64_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT AddOutput(AkOutputSettings, UInt64 ByRef, UInt64[]) declare in AkSoundEngine
bool w_i4oPu8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oPu8o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             
    // LuaValToCSVal P primitive
    uint64_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv1);
    uint64_t* p1 = &up1;
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, uint64_t* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint64_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT AddOutput(AkOutputSettings, UInt64 ByRef, UInt64[], UInt32) declare in AkSoundEngine
bool w_i4oPu8ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oPu8ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             
    // LuaValToCSVal P primitive
    uint64_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv1);
    uint64_t* p1 = &up1;
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, uint64_t* p2, Il2CppObject* p3, uint32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint64_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetObjectPosition(UnityEngine.GameObject, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3) declare in AkSoundEngine
bool w_i4oS_r4r4r4_S_r4r4r4_S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oS_r4r4r4_S_r4r4r4_S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetListenerSpatialization(UnityEngine.GameObject, Boolean, AkChannelConfig) declare in AkSoundEngine
bool w_i4obo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4obo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, bool p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetListenerSpatialization(UnityEngine.GameObject, Boolean, AkChannelConfig, Single[]) declare in AkSoundEngine
bool w_i4oboo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oboo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, bool p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 BinarySearch(System.Array, Int32, Int32, System.Object) declare in System.Array
bool w_i4oi4i4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4i4O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 BinarySearch(System.Array, Int32, Int32, System.Object, System.Collections.IComparer) declare in System.Array
bool w_i4oi4i4Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4i4Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToBase64CharArray(Byte[], Int32, Int32, Char[], Int32) declare in System.Convert
bool w_i4oi4i4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4i4oi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToBase64CharArray(Byte[], Int32, Int32, Char[], Int32, System.Base64FormattingOptions) declare in System.Convert
bool w_i4oi4i4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oi4i4oi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, Il2CppObject* p4, int32_t p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Compare(Assets.Scripts.GameSystem.Project8PlayerSortElement, Assets.Scripts.GameSystem.Project8PlayerSortElement) declare in Assets.Scripts.GameSystem.Project8PlayerSortElement
bool w_i4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetGameObjectDryLevelValue(UnityEngine.GameObject, UnityEngine.GameObject, Single ByRef) declare in AkSoundEngine
bool w_i4ooPr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ooPr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
             
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;

    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetObjectObstructionAndOcclusion(UnityEngine.GameObject, UnityEngine.GameObject, Single ByRef, Single ByRef) declare in AkSoundEngine
bool w_i4ooPr4Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ooPr4Pr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
             
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;
     
    // LuaValToCSVal P primitive
    float up3 = 0;
    if (3 < lua_args_len)
        up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv3);
    float* p3 = &up3;

    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float* p3, float* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	int ret3 = converter::Converter<float>::toScript(apis, env, *p3);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetGameObjectAuxSendValues(UnityEngine.GameObject, AkAuxSendArray, UInt32 ByRef) declare in AkSoundEngine
bool w_i4ooPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ooPu4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
             
    // LuaValToCSVal P primitive
    uint32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv2);
    uint32_t* p2 = &up2;

    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, uint32_t* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret2 = converter::Converter<uint32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Compare(System.Uri, System.Uri, System.UriComponents, System.UriFormat, System.StringComparison) declare in System.Uri
bool w_i4ooi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ooi4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetMultipleObstructionAndOcclusion(UnityEngine.GameObject, UnityEngine.GameObject, AkObstructionOcclusionValuesArray, UInt32) declare in AkSoundEngine
bool w_i4ooou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ooou4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, uint32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetGameObjectOutputBusVolume(UnityEngine.GameObject, UnityEngine.GameObject, Single) declare in AkSoundEngine
bool w_i4oor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oor4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetObjectObstructionAndOcclusion(UnityEngine.GameObject, UnityEngine.GameObject, Single, Single) declare in AkSoundEngine
bool w_i4oor4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oor4r4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, float p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetMultiplePositions(UnityEngine.GameObject, AkPositionArray, UInt16) declare in AkSoundEngine
bool w_i4oou2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oou2");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, uint16_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetMultiplePositions(UnityEngine.GameObject, AkPositionArray, UInt16, AkMultiPositionType) declare in AkSoundEngine
bool w_i4oou2i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oou2i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint16_t p2 = converter::Converter<uint16_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, uint16_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetGameObjectAuxSendValues(UnityEngine.GameObject, AkAuxSendArray, UInt32) declare in AkSoundEngine
bool w_i4oou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4oou4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, uint32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetScalingFactor(UnityEngine.GameObject, Single) declare in AkSoundEngine
bool w_i4or4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4or4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetObjectPosition(UnityEngine.GameObject, Single, Single, Single, Single, Single, Single, Single, Single, Single) declare in AkSoundEngine
bool w_i4or4r4r4r4r4r4r4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4or4r4r4r4r4r4r4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    int _sv9 = apis->get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 10) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv7))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv8))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv9))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(apis, env, _sv7);
                
    // LuaValToCSVal P any
    float p8 = converter::Converter<float>::toCpp(apis, env, _sv8);
                
    // LuaValToCSVal P any
    float p9 = converter::Converter<float>::toCpp(apis, env, _sv9);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT RegisterGameObjInternal_WithName(UnityEngine.GameObject, System.String) declare in AkSoundEngine
bool w_i4os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4os");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetVoiceFileTimeLengthByEngine(gcloud_voice.GCloudVoiceEngine, System.String, Single ByRef) declare in LuaCallCSharpInteraction
bool w_i4osPr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4osPr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);     
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;

    typedef int32_t (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, float* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetMedia(AkSourceSettingsArray, UInt32) declare in AkSoundEngine
bool w_i4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, uint32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT StartOutputCaptureToCallback(CaptureOutputCallbackDelegate, UInt32, Boolean) declare in AkSoundEngine
bool w_i4ou4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ou4b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, uint32_t p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetSpeakerAngles(Single[], UInt32, Single) declare in AkSoundEngine
bool w_i4ou4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ou4r4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, uint32_t p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetSpeakerAngles(Single[], UInt32, Single, UInt64) declare in AkSoundEngine
bool w_i4ou4r4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ou4r4u8");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint64_t p3 = converter::Converter<uint64_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, uint32_t p2, float p3, uint64_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT ReplaceOutput(AkOutputSettings, UInt64) declare in AkSoundEngine
bool w_i4ou8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ou8");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(Il2CppObject* p1, uint64_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT ReplaceOutput(AkOutputSettings, UInt64, UInt64 ByRef) declare in AkSoundEngine
bool w_i4ou8Pu8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ou8Pu8");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal P primitive
    uint64_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<uint64_t>>::toCpp(apis, env, _sv2);
    uint64_t* p2 = &up2;

    typedef int32_t (*FuncToCall)(Il2CppObject* p1, uint64_t p2, uint64_t* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret2 = converter::Converter<uint64_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetWwiseAudioDataCallback(IntPtr, Int32) declare in AkSoundEngine
bool w_i4pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4pi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(void* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT LoadBankMemoryView(IntPtr, UInt32, UInt32 ByRef) declare in AkSoundEngine
bool w_i4pu4Pu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4pu4Pu4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal P primitive
    uint32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv2);
    uint32_t* p2 = &up2;

    typedef int32_t (*FuncToCall)(void* p1, uint32_t p2, uint32_t* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret2 = converter::Converter<uint32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT LoadAndDecodeBankFromMemory(IntPtr, UInt32, Boolean, System.String, Boolean, UInt32 ByRef) declare in AkSoundEngine
bool w_i4pu4bsbPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4pu4bsbPu4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (!apis->is_object(env, _sv5)) return false;        
    }
        
    // LuaValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
            // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3);        
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
             
    // LuaValToCSVal P primitive
    uint32_t up5 = 0;
    if (5 < lua_args_len)
        up5 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv5);
    uint32_t* p5 = &up5;

    typedef int32_t (*FuncToCall)(void* p1, uint32_t p2, bool p3, Il2CppString* p4, bool p5, uint32_t* p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret5 = converter::Converter<uint32_t>::toScript(apis, env, *p5);
	apis->add_return(info, r);
	apis->add_return(info, ret5);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT LoadBankMemoryView(IntPtr, UInt32, BankCallback, System.Object, UInt32 ByRef) declare in AkSoundEngine
bool w_i4pu4oOPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4pu4oOPu4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!apis->is_binary(env, _sv0) && !apis->is_null(env, _sv0) && !apis->is_undefined(env, _sv0)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!apis->is_object(env, _sv4)) return false;        
    }
        
    // LuaValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
             
    // LuaValToCSVal P primitive
    uint32_t up4 = 0;
    if (4 < lua_args_len)
        up4 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv4);
    uint32_t* p4 = &up4;

    typedef int32_t (*FuncToCall)(void* p1, uint32_t p2, Il2CppObject* p3, Il2CppObject* p4, uint32_t* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret4 = converter::Converter<uint32_t>::toScript(apis, env, *p4);
	apis->add_return(info, r);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(Single) declare in System.Convert
bool w_i4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(float p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetBankLoadIOSettings(Single, Char) declare in AkSoundEngine
bool w_i4r4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4r4c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(float p1, Il2CppChar p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(Double) declare in System.Convert
bool w_i4r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(double p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 NameToLayer(System.String) declare in UnityEngine.LayerMask
bool w_i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef int32_t (*FuncToCall)(Il2CppString* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetVoiceFileTimeLength(System.String, Single ByRef) declare in LuaCallCSharpInteraction
bool w_i4sPr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sPr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal P primitive
    float up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv1);
    float* p1 = &up1;

    typedef int32_t (*FuncToCall)(Il2CppString* p1, float* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<float>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetBufferStatusForPinnedEvent(System.String, Single ByRef, Int32 ByRef) declare in AkSoundEngine
bool w_i4sPr4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sPr4Pi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal P primitive
    float up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv1);
    float* p1 = &up1;
     
    // LuaValToCSVal P primitive
    int32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef int32_t (*FuncToCall)(Il2CppString* p1, float* p2, int32_t* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<float>::toScript(apis, env, *p1);
	int ret2 = converter::Converter<int32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT LoadBank(System.String, UInt32 ByRef) declare in AkSoundEngine
bool w_i4sPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sPu4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;

    typedef int32_t (*FuncToCall)(Il2CppString* p1, uint32_t* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT QueryAudioObjectIDs(System.String, UInt32 ByRef, AkObjectInfoArray) declare in AkSoundEngine
bool w_i4sPu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sPu4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, uint32_t* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 InitContext(System.String, Boolean, Int32) declare in GCloud.GPM.GPMAgent
bool w_i4sbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sbDi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef int32_t (*FuncToCall)(Il2CppString* p1, bool p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT LoadAndDecodeBank(System.String, Boolean, UInt32 ByRef) declare in AkSoundEngine
bool w_i4sbPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sbPu4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal P primitive
    uint32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv2);
    uint32_t* p2 = &up2;

    typedef int32_t (*FuncToCall)(Il2CppString* p1, bool p2, uint32_t* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret2 = converter::Converter<uint32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PinEventInStreamCache(System.String, Char, Char) declare in AkSoundEngine
bool w_i4scc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4scc");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppChar p2, Il2CppChar p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(System.String, Int32) declare in System.Convert
bool w_i4si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT ExecuteActionOnEvent(System.String, AkActionOnEventType, UnityEngine.GameObject) declare in AkSoundEngine
bool w_i4si4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT ExecuteActionOnEvent(System.String, AkActionOnEventType, UnityEngine.GameObject, Int32) declare in AkSoundEngine
bool w_i4si4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4oi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT ExecuteActionOnEvent(System.String, AkActionOnEventType, UnityEngine.GameObject, Int32, AkCurveInterpolation) declare in AkSoundEngine
bool w_i4si4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4oi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT ExecuteActionOnEvent(System.String, AkActionOnEventType, UnityEngine.GameObject, Int32, AkCurveInterpolation, UInt32) declare in AkSoundEngine
bool w_i4si4oi4i4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4oi4i4u4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppObject* p3, int32_t p4, int32_t p5, uint32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Compare(System.String, Int32, System.String, Int32, Int32) declare in System.String
bool w_i4si4si4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Compare(System.String, Int32, System.String, Int32, Int32, Boolean) declare in System.String
bool w_i4si4si4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, int32_t p4, int32_t p5, bool p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Compare(System.String, Int32, System.String, Int32, Int32, Boolean, System.Globalization.CultureInfo) declare in System.String
bool w_i4si4si4i4bo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4bo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv6, TIp6, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
            
    // LuaValToCSVal o/O
    Il2CppObject* p6 = LuaValueToCSRef(apis, TIp6, env, _sv6);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, int32_t p4, int32_t p5, bool p6, Il2CppObject* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Compare(System.String, Int32, System.String, Int32, Int32, System.StringComparison) declare in System.String
bool w_i4si4si4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Compare(System.String, Int32, System.String, Int32, Int32, System.Globalization.CultureInfo, System.Globalization.CompareOptions) declare in System.String
bool w_i4si4si4i4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4si4i4oi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);        
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, Il2CppString* p3, int32_t p4, int32_t p5, Il2CppObject* p6, int32_t p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PostString(System.String, AkMonitorErrorLevel, UInt32) declare in AkSoundEngine
bool w_i4si4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4u4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, uint32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PostString(System.String, AkMonitorErrorLevel, UInt32, UnityEngine.GameObject) declare in AkSoundEngine
bool w_i4si4u4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4u4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, uint32_t p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PostString(System.String, AkMonitorErrorLevel, UInt32, UnityEngine.GameObject, UInt32) declare in AkSoundEngine
bool w_i4si4u4ou4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4u4ou4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, uint32_t p3, Il2CppObject* p4, uint32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PostString(System.String, AkMonitorErrorLevel, UInt32, UnityEngine.GameObject, UInt32, Boolean) declare in AkSoundEngine
bool w_i4si4u4ou4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4si4u4ou4b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, int32_t p2, uint32_t p3, Il2CppObject* p4, uint32_t p5, bool p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(System.String, System.IFormatProvider) declare in System.Convert
bool w_i4so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT LoadBank(System.String, BankCallback, System.Object, UInt32 ByRef) declare in AkSoundEngine
bool w_i4soOPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4soOPu4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
             
    // LuaValToCSVal P primitive
    uint32_t up3 = 0;
    if (3 < lua_args_len)
        up3 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv3);
    uint32_t* p3 = &up3;

    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, uint32_t* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret3 = converter::Converter<uint32_t>::toScript(apis, env, *p3);
	apis->add_return(info, r);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetSwitch(System.String, UnityEngine.GameObject, UInt32 ByRef) declare in AkSoundEngine
bool w_i4soPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4soPu4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
             
    // LuaValToCSVal P primitive
    uint32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv2);
    uint32_t* p2 = &up2;

    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, uint32_t* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret2 = converter::Converter<uint32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SeekOnEvent(System.String, UnityEngine.GameObject, Int32) declare in AkSoundEngine
bool w_i4soi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4soi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SeekOnEvent(System.String, UnityEngine.GameObject, Int32, Boolean) declare in AkSoundEngine
bool w_i4soi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4soi4b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, bool p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SeekOnEvent(System.String, UnityEngine.GameObject, Int32, Boolean, UInt32) declare in AkSoundEngine
bool w_i4soi4bu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4soi4bu4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, bool p4, uint32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT ResetRTPCValue(System.String, UnityEngine.GameObject, Int32, AkCurveInterpolation) declare in AkSoundEngine
bool w_i4soi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4soi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT ResetRTPCValue(System.String, UnityEngine.GameObject, Int32, AkCurveInterpolation, Boolean) declare in AkSoundEngine
bool w_i4soi4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4soi4i4b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, int32_t p4, bool p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SeekOnEvent(System.String, UnityEngine.GameObject, Single) declare in AkSoundEngine
bool w_i4sor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sor4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SeekOnEvent(System.String, UnityEngine.GameObject, Single, Boolean) declare in AkSoundEngine
bool w_i4sor4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sor4b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, float p3, bool p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SeekOnEvent(System.String, UnityEngine.GameObject, Single, Boolean, UInt32) declare in AkSoundEngine
bool w_i4sor4bu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sor4bu4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, float p3, bool p4, uint32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetRTPCValue(System.String, UnityEngine.GameObject, UInt32, Single ByRef, Int32 ByRef) declare in AkSoundEngine
bool w_i4sou4Pr4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sou4Pr4Pi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!apis->is_object(env, _sv3)) return false;
        if (!apis->is_object(env, _sv4)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
             
    // LuaValToCSVal P primitive
    float up3 = 0;
    if (3 < lua_args_len)
        up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv3);
    float* p3 = &up3;
     
    // LuaValToCSVal P primitive
    int32_t up4 = 0;
    if (4 < lua_args_len)
        up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv4);
    int32_t* p4 = &up4;

    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, uint32_t p3, float* p4, int32_t* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret3 = converter::Converter<float>::toScript(apis, env, *p3);
	int ret4 = converter::Converter<int32_t>::toScript(apis, env, *p4);
	apis->add_return(info, r);
	apis->add_return(info, ret3);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT UnloadBank(System.String, IntPtr) declare in AkSoundEngine
bool w_i4sp(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sp");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT UnloadBank(System.String, IntPtr, BankCallback, System.Object) declare in AkSoundEngine
bool w_i4spoO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4spoO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, void* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValue(System.String, Single) declare in AkSoundEngine
bool w_i4sr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sr4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValue(System.String, Single, UnityEngine.GameObject) declare in AkSoundEngine
bool w_i4sr4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sr4o");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, float p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValue(System.String, Single, UnityEngine.GameObject, Int32) declare in AkSoundEngine
bool w_i4sr4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sr4oi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, float p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValue(System.String, Single, UnityEngine.GameObject, Int32, AkCurveInterpolation) declare in AkSoundEngine
bool w_i4sr4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sr4oi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, float p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValue(System.String, Single, UnityEngine.GameObject, Int32, AkCurveInterpolation, Boolean) declare in AkSoundEngine
bool w_i4sr4oi4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sr4oi4i4b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, float p2, Il2CppObject* p3, int32_t p4, int32_t p5, bool p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValueByPlayingID(System.String, Single, UInt32) declare in AkSoundEngine
bool w_i4sr4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sr4u4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, float p2, uint32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValueByPlayingID(System.String, Single, UInt32, Int32) declare in AkSoundEngine
bool w_i4sr4u4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sr4u4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, float p2, uint32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValueByPlayingID(System.String, Single, UInt32, Int32, AkCurveInterpolation) declare in AkSoundEngine
bool w_i4sr4u4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sr4u4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, float p2, uint32_t p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValueByPlayingID(System.String, Single, UInt32, Int32, AkCurveInterpolation, Boolean) declare in AkSoundEngine
bool w_i4sr4u4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sr4u4i4i4b");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, float p2, uint32_t p3, int32_t p4, int32_t p5, bool p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Compare(System.String, System.String) declare in System.String
bool w_i4ss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ss");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Compare(System.String, System.String, Boolean) declare in System.String
bool w_i4ssb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssb");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Compare(System.String, System.String, Boolean, System.Globalization.CultureInfo) declare in System.String
bool w_i4ssbo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssbo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, bool p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Compare(System.String, System.String, System.StringComparison) declare in System.String
bool w_i4ssi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetSwitch(System.String, System.String, UnityEngine.GameObject) declare in AkSoundEngine
bool w_i4sso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4sso");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 Compare(System.String, System.String, System.Globalization.CultureInfo, System.Globalization.CompareOptions) declare in System.String
bool w_i4ssoi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ssoi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetMixer(System.String, UInt32) declare in AkSoundEngine
bool w_i4su4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4su4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, uint32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetBusEffect(System.String, UInt32, UInt32) declare in AkSoundEngine
bool w_i4su4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4su4u4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(Il2CppString* p1, uint32_t p2, uint32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.TouchScreenKeyboardType ToUType(com.pixui.EKeyboardType) declare in com.pixui.PxMisc
bool w_i4t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4t");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef int32_t (*FuncToCall)(void*,const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetFirstVisibleIndex(Boolean) declare in UIWidgets.EasyListView
bool w_i4tDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tDb");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef int32_t (*FuncToCall)(void*,bool p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 CompareTo(System.Object) declare in System.String
bool w_i4tO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tO");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetTrails(Trails ByRef) declare in UnityEngine.ParticleSystem
bool w_i4tPS_oooooi4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tPS_oooooi4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_oooooi4i4_* p0 = DataTransfer::GetPointer<S_oooooi4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_oooooi4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef int32_t (*FuncToCall)(void*,struct S_oooooi4i4_* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetPositions(Unity.Collections.NativeSlice`1[UnityEngine.Vector3]) declare in UnityEngine.LineRenderer
bool w_i4tS_Pu1i4i4i4i4S_pi4i4__(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_Pu1i4i4i4i4S_pi4i4__");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_Pu1i4i4i4i4S_pi4i4__* pp0 = DataTransfer::GetPointer<S_Pu1i4i4i4i4S_pi4i4__>(apis, env, _sv0);
    S_Pu1i4i4i4i4S_pi4i4__ p0 = pp0 ? *pp0 : S_Pu1i4i4i4i4S_pi4i4__ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_Pu1i4i4i4i4S_pi4i4__ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetPositions(Unity.Collections.NativeArray`1[UnityEngine.Vector3]) declare in UnityEngine.LineRenderer
bool w_i4tS_Pvi4i4i4S_pi4i4_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_Pvi4i4i4S_pi4i4_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32) declare in UnityEngine.ParticleSystem
bool w_i4tS_Pvi4i4i4S_pi4i4_i4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_Pvi4i4i4S_pi4i4_i4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32, Int32) declare in UnityEngine.ParticleSystem
bool w_i4tS_Pvi4i4i4S_pi4i4_i4_i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_Pvi4i4i4S_pi4i4_i4_i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_Pvi4i4i4S_pi4i4_i4_* pp0 = DataTransfer::GetPointer<S_Pvi4i4i4S_pi4i4_i4_>(apis, env, _sv0);
    S_Pvi4i4i4S_pi4i4_i4_ p0 = pp0 ? *pp0 : S_Pvi4i4i4S_pi4i4_i4_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(void*,struct S_Pvi4i4i4S_pi4i4_i4_ p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetLineCount(UnityEngine.Vector2) declare in ShrinkText
bool w_i4tS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_r4r4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetActorPopulationCost(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]) declare in Assets.Scripts.GameLogic.PlayerChessManager
bool w_i4tS_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_u4o_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetHeroUnlockedGridNum(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker], ResData.RES_PROJECT8_EQUIP_CONTAINER_TYPE) declare in Assets.Scripts.GameLogic.Project8Equipment
bool w_i4tS_u4o_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u4o_i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(void*,struct S_u4o_ p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 CompareTo(System.DateTime) declare in System.DateTime
bool w_i4tS_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tS_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef int32_t (*FuncToCall)(void*,struct S_u8_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 IndexOf(Char) declare in System.String
bool w_i4tc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tc");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppChar p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 IndexOf(Char, Int32) declare in System.String
bool w_i4tci4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tci4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 IndexOf(Char, Int32, Int32) declare in System.String
bool w_i4tci4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tci4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetCacheCountLodFilename(Assets.Scripts.Framework.AssetService.AssetType, System.String, System.Object) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_i4ti1sO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti1sO");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(void*,int8_t p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 NBGetCurrencyShopItemCount(Int32) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_i4ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// CurlUnity.CURLE GetInfo(CurlUnity.CURLINFO, Int64 ByRef) declare in CurlUnity.CurlEasy
bool w_i4ti4Pi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4Pi8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    int64_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(apis, env, _sv1);
    int64_t* p1 = &up1;

    typedef int32_t (*FuncToCall)(void*,int32_t p1, int64_t* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<int64_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// CurlUnity.CURLE GetInfo(CurlUnity.CURLINFO, CurlUnity.CurlSlist ByRef) declare in CurlUnity.CurlEasy
bool w_i4ti4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4Po");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, Il2CppObject** p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = CSRefToLuaValue(apis, env, TIp1, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// CurlUnity.CURLE GetInfo(CurlUnity.CURLINFO, Double ByRef) declare in CurlUnity.CurlEasy
bool w_i4ti4Pr8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4Pr8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    double up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<double>>::toCpp(apis, env, _sv1);
    double* p1 = &up1;

    typedef int32_t (*FuncToCall)(void*,int32_t p1, double* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<double>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// CurlUnity.CURLE GetInfo(CurlUnity.CURLINFO, System.String ByRef) declare in CurlUnity.CurlEasy
bool w_i4ti4Ps(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4Ps");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal Ps
    Il2CppString* up1 = converter::Converter<std::reference_wrapper<Il2CppString*>>::toCpp(apis, env, _sv1); // string ref
    Il2CppString** p1 = &up1;
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, Il2CppString** p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<Il2CppString*>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetCustomCoin(ResData.CUSTOM_COIN_TYPE, Boolean) declare in Assets.Scripts.GameLogic.PlayerCaptainControl
bool w_i4ti4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 IndexOf(Int32, Int32) declare in System.Collections.Generic.List`1[System.Int32]
bool w_i4ti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 IndexOf(Int32, Int32, Int32) declare in System.Collections.Generic.List`1[System.Int32]
bool w_i4ti4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 BinarySearch(Int32, Int32, Int32, System.Collections.Generic.IComparer`1[System.Int32]) declare in System.Collections.Generic.List`1[System.Int32]
bool w_i4ti4i4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4i4o");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 FindIndex(Int32, Int32, System.Predicate`1[UIEventDelegate]) declare in System.Collections.Generic.List`1[UIEventDelegate]
bool w_i4ti4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4o");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 BinarySearch(Int32, Int32, UIEventDelegate, System.Collections.Generic.IComparer`1[UIEventDelegate]) declare in System.Collections.Generic.List`1[UIEventDelegate]
bool w_i4ti4i4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4oo");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 BinarySearch(Int32, Int32, System.String, System.Collections.Generic.IComparer`1[System.String]) declare in System.Collections.Generic.List`1[System.String]
bool w_i4ti4i4so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i4so");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, int32_t p2, Il2CppString* p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// CurlUnity.CURLE SetOpt(CurlUnity.CURLOPT, Int64) declare in CurlUnity.CurlEasy
bool w_i4ti4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, int64_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 FindIndex(Int32, System.Predicate`1[UIEventDelegate]) declare in System.Collections.Generic.List`1[UIEventDelegate]
bool w_i4ti4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4o");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// CurlUnity.CURLE SetOpt(CurlUnity.CURLOPT, IntPtr) declare in CurlUnity.CurlEasy
bool w_i4ti4p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4p");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// CurlUnity.CURLE SetOpt(CurlUnity.CURLOPT, System.String) declare in CurlUnity.CurlEasy
bool w_i4ti4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4s");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef int32_t (*FuncToCall)(void*,int32_t p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetEquipExtraValue(Int32, UInt32, UInt32[]) declare in Assets.Scripts.UI.InGameCommon.UIPropData
bool w_i4ti4u4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti4u4o");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(void*,int32_t p1, uint32_t p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// QTSErrorCode Mount(Int64) declare in Assets.Scripts.Resource.Package.OnAirCollection
bool w_i4ti8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ti8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(void*,int64_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetInitOffsetOfSubCanvas(UnityEngine.Canvas) declare in UIPrefabBase
bool w_i4to(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4to");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 IndexOfAny(Char[], Int32) declare in System.String
bool w_i4toi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 IndexOfAny(Char[], Int32, Int32) declare in System.String
bool w_i4toi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4toi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 BinarySearch(UIEventDelegate, System.Collections.Generic.IComparer`1[UIEventDelegate]) declare in System.Collections.Generic.List`1[UIEventDelegate]
bool w_i4too(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4too");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetSprites(UnityEngine.Sprite[], System.String) declare in UnityEngine.U2D.SpriteAtlas
bool w_i4tos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tos");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef int32_t (*FuncToCall)(void*,Il2CppObject* p1, Il2CppString* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 NameIndexOf(System.String) declare in UnityEngine.Object
bool w_i4ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4ts");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef int32_t (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 IndexOf(System.String, Int32) declare in System.String
bool w_i4tsi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SeekOnEvent(System.String, Int32, UInt32, UnityEngine.GameObject, Boolean) declare in Assets.Scripts.Sound.CSoundManager
bool w_i4tsi4Du4DoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsi4Du4DoDb");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (lua_args_len > 4 && !converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    uint32_t p2 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
                // LuaValToCSVal ref with default
    Il2CppObject* p3 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 3, TIp3); // LuaValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef int32_t (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, uint32_t p3, Il2CppObject* p4, bool p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 IndexOf(System.String, Int32, Int32) declare in System.String
bool w_i4tsi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 IndexOf(System.String, Int32, Int32, System.StringComparison) declare in System.String
bool w_i4tsi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsi4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppString* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 BinarySearch(System.String, System.Collections.Generic.IComparer`1[System.String]) declare in System.Collections.Generic.List`1[System.String]
bool w_i4tso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tso");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef int32_t (*FuncToCall)(void*,Il2CppString* p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// enSoundBankExistState GetSoundBankInfo(System.String, UInt32, Assets.Scripts.Sound.stSoundBankInfo ByRef, Assets.Scripts.Sound.stSoundBankResourceInfo ByRef, Assets.Scripts.Sound.enSoundLOD ByRef) declare in Assets.Scripts.Sound.CSoundManager
bool w_i4tsu4PS_si4_PS_sb_Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tsu4PS_si4_PS_sb_Pi4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!apis->is_object(env, _sv3)) return false;
        if (!apis->is_object(env, _sv4)) return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal Pstruct
    S_si4_* p2 = DataTransfer::GetPointer<S_si4_>(apis, env, apis->unboxing(env, _sv2)); // valuetype ref
    S_si4_ up2;
    if (!p2) {
        memset(&up2, 0, sizeof(p2));
        p2 = &up2;
    }
             
    // LuaValToCSVal Pstruct
    S_sb_* p3 = DataTransfer::GetPointer<S_sb_>(apis, env, apis->unboxing(env, _sv3)); // valuetype ref
    S_sb_ up3;
    if (!p3) {
        memset(&up3, 0, sizeof(p3));
        p3 = &up3;
    }
             
    // LuaValToCSVal P primitive
    int32_t up4 = 0;
    if (4 < lua_args_len)
        up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv4);
    int32_t* p4 = &up4;

    typedef int32_t (*FuncToCall)(void*,Il2CppString* p1, uint32_t p2, struct S_si4_* p3, struct S_sb_* p4, int32_t* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);                
    int ret2;
    if (p2 == &up2)
    {
        ret2 = DataTransfer::CopyValueType(apis, env, *p2, TIp2);    
        apis->update_boxed_value(env, _sv2, ret2);
    }
    else
    {
        ret2 = apis->native_object_to_value(env, TIp2, p2, false);
    }
                
    int ret3;
    if (p3 == &up3)
    {
        ret3 = DataTransfer::CopyValueType(apis, env, *p3, TIp3);    
        apis->update_boxed_value(env, _sv3, ret3);
    }
    else
    {
        ret3 = apis->native_object_to_value(env, TIp3, p3, false);
    }

	int ret4 = converter::Converter<int32_t>::toScript(apis, env, *p4);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
	apis->add_return(info, ret3);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetSceneCountBySceneSkinID(UInt32) declare in Assets.Scripts.GameLogic.Project8Logic
bool w_i4tu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(void*,uint32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 FindHeroSimpleEquipmentSlot(UInt32, Assets.Scripts.GameSystem.EquipRecipe ByRef) declare in Assets.Scripts.GameLogic.Project8Equipment
bool w_i4tu4PS_u4u4u4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tu4PS_u4u4u4_");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal Pstruct
    S_u4u4u4_* p1 = DataTransfer::GetPointer<S_u4u4u4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u4u4u4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef int32_t (*FuncToCall)(void*,uint32_t p1, struct S_u4u4u4_* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetHeroExtraPropValue(UInt32, UInt32) declare in Assets.Scripts.UI.InGameCommon.UIPropData
bool w_i4tu4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tu4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 GetHeroConfPropValue(UInt32, UInt32, Int32, Int32) declare in Assets.Scripts.UI.InGameCommon.UIPropData
bool w_i4tu4u4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4tu4u4i4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(void*,uint32_t p1, uint32_t p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(Byte) declare in System.Convert
bool w_i4u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(uint8_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(UInt16) declare in System.Convert
bool w_i4u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(uint16_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(UInt32) declare in System.Convert
bool w_i4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetSourcePlayPosition(UInt32, Int32 ByRef) declare in AkSoundEngine
bool w_i4u4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;

    typedef int32_t (*FuncToCall)(uint32_t p1, int32_t* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetSourceStreamBuffering(UInt32, Int32 ByRef, Int32 ByRef) declare in AkSoundEngine
bool w_i4u4Pi4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4Pi4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
     
    // LuaValToCSVal P primitive
    int32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef int32_t (*FuncToCall)(uint32_t p1, int32_t* p2, int32_t* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	int ret2 = converter::Converter<int32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetSourcePlayPosition(UInt32, Int32 ByRef, Boolean) declare in AkSoundEngine
bool w_i4u4Pi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4Pi4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    int32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv1);
    int32_t* p1 = &up1;
        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, int32_t* p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<int32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetBufferStatusForPinnedEvent(UInt32, Single ByRef, Int32 ByRef) declare in AkSoundEngine
bool w_i4u4Pr4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4Pr4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    float up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv1);
    float* p1 = &up1;
     
    // LuaValToCSVal P primitive
    int32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef int32_t (*FuncToCall)(uint32_t p1, float* p2, int32_t* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<float>::toScript(apis, env, *p1);
	int ret2 = converter::Converter<int32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetState(UInt32, UInt32 ByRef) declare in AkSoundEngine
bool w_i4u4Pu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4Pu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;

    typedef int32_t (*FuncToCall)(uint32_t p1, uint32_t* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT DynamicSequenceGetPauseTimes(UInt32, UInt32 ByRef, UInt32 ByRef) declare in AkSoundEngine
bool w_i4u4Pu4Pu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4Pu4Pu4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;
     
    // LuaValToCSVal P primitive
    uint32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv2);
    uint32_t* p2 = &up2;

    typedef int32_t (*FuncToCall)(uint32_t p1, uint32_t* p2, uint32_t* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	int ret2 = converter::Converter<uint32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetDeviceList(UInt32, UInt32 ByRef, AkDeviceDescriptionArray) declare in AkSoundEngine
bool w_i4u4Pu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4Pu4o");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    uint32_t up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv1);
    uint32_t* p1 = &up1;
    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, uint32_t* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<uint32_t>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetReflectionsOrder(UInt32, Boolean) declare in AkSoundEngine
bool w_i4u4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, bool p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PinEventInStreamCache(UInt32, Char, Char) declare in AkSoundEngine
bool w_i4u4cc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4cc");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    Il2CppChar p2 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppChar p2, Il2CppChar p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT DynamicSequencePlay(UInt32, Int32) declare in AkSoundEngine
bool w_i4u4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT Seek(UInt32, Int32, Boolean) declare in AkSoundEngine
bool w_i4u4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4i4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, int32_t p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT DynamicSequencePlay(UInt32, Int32, AkCurveInterpolation) declare in AkSoundEngine
bool w_i4u4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4i4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT ExecuteActionOnEvent(UInt32, AkActionOnEventType, UnityEngine.GameObject) declare in AkSoundEngine
bool w_i4u4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4i4o");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, int32_t p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT ExecuteActionOnEvent(UInt32, AkActionOnEventType, UnityEngine.GameObject, Int32) declare in AkSoundEngine
bool w_i4u4i4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4i4oi4");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, int32_t p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT ExecuteActionOnEvent(UInt32, AkActionOnEventType, UnityEngine.GameObject, Int32, AkCurveInterpolation) declare in AkSoundEngine
bool w_i4u4i4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4i4oi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, int32_t p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT ExecuteActionOnEvent(UInt32, AkActionOnEventType, UnityEngine.GameObject, Int32, AkCurveInterpolation, UInt32) declare in AkSoundEngine
bool w_i4u4i4oi4i4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4i4oi4i4u4");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(apis, env, _sv5);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, int32_t p2, Il2CppObject* p3, int32_t p4, int32_t p5, uint32_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT StopMIDIOnEvent(UInt32, UnityEngine.GameObject) declare in AkSoundEngine
bool w_i4u4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4o");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT LoadBank(UInt32, BankCallback, System.Object) declare in AkSoundEngine
bool w_i4u4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4oO");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetSwitch(UInt32, UnityEngine.GameObject, UInt32 ByRef) declare in AkSoundEngine
bool w_i4u4oPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4oPu4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
             
    // LuaValToCSVal P primitive
    uint32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv2);
    uint32_t* p2 = &up2;

    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, uint32_t* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret2 = converter::Converter<uint32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetPlayingSegmentInfo(UInt32, AkSegmentInfo, Boolean) declare in AkSoundEngine
bool w_i4u4ob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4ob");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SeekOnEvent(UInt32, UnityEngine.GameObject, Int32) declare in AkSoundEngine
bool w_i4u4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4oi4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SeekOnEvent(UInt32, UnityEngine.GameObject, Int32, Boolean) declare in AkSoundEngine
bool w_i4u4oi4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4oi4b");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, int32_t p3, bool p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SeekOnEvent(UInt32, UnityEngine.GameObject, Int32, Boolean, UInt32) declare in AkSoundEngine
bool w_i4u4oi4bu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4oi4bu4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, int32_t p3, bool p4, uint32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT ResetRTPCValue(UInt32, UnityEngine.GameObject, Int32, AkCurveInterpolation) declare in AkSoundEngine
bool w_i4u4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4oi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT ResetRTPCValue(UInt32, UnityEngine.GameObject, Int32, AkCurveInterpolation, Boolean) declare in AkSoundEngine
bool w_i4u4oi4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4oi4i4b");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, int32_t p3, int32_t p4, bool p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SendPluginCustomGameData(UInt32, UnityEngine.GameObject, AkPluginType, UInt32, UInt32, IntPtr, UInt32) declare in AkSoundEngine
bool w_i4u4oi4u4u4pu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4oi4u4u4pu4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;
        if (!apis->is_binary(env, _sv5) && !apis->is_null(env, _sv5) && !apis->is_undefined(env, _sv5)) return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv6))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    void* p5 = DataTransfer::GetPointer<void>(apis, env, _sv5);
                
    // LuaValToCSVal P any
    uint32_t p6 = converter::Converter<uint32_t>::toCpp(apis, env, _sv6);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, int32_t p3, uint32_t p4, uint32_t p5, void* p6, uint32_t p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetSourceMultiplePlayPositions(UInt32, UInt32[], UInt32[], Int32[], UInt32 ByRef) declare in AkSoundEngine
bool w_i4u4oooPu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4oooPu4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!apis->is_object(env, _sv4)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
             
    // LuaValToCSVal P primitive
    uint32_t up4 = 0;
    if (4 < lua_args_len)
        up4 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv4);
    uint32_t* p4 = &up4;

    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, uint32_t* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret4 = converter::Converter<uint32_t>::toScript(apis, env, *p4);
	apis->add_return(info, r);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetSourceMultiplePlayPositions(UInt32, UInt32[], UInt32[], Int32[], UInt32 ByRef, Boolean) declare in AkSoundEngine
bool w_i4u4oooPu4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4oooPu4b");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!apis->is_object(env, _sv4)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
             
    // LuaValToCSVal P primitive
    uint32_t up4 = 0;
    if (4 < lua_args_len)
        up4 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv4);
    uint32_t* p4 = &up4;
        
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppObject* p4, uint32_t* p5, bool p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret4 = converter::Converter<uint32_t>::toScript(apis, env, *p4);
	apis->add_return(info, r);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT PostMIDIOnEvent(UInt32, UnityEngine.GameObject, AkMIDIPostArray, UInt16) declare in AkSoundEngine
bool w_i4u4oou2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4oou2");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<uint16_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    uint16_t p3 = converter::Converter<uint16_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, Il2CppObject* p3, uint16_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SeekOnEvent(UInt32, UnityEngine.GameObject, Single) declare in AkSoundEngine
bool w_i4u4or4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4or4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SeekOnEvent(UInt32, UnityEngine.GameObject, Single, Boolean) declare in AkSoundEngine
bool w_i4u4or4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4or4b");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, float p3, bool p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SeekOnEvent(UInt32, UnityEngine.GameObject, Single, Boolean, UInt32) declare in AkSoundEngine
bool w_i4u4or4bu4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4or4bu4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, float p3, bool p4, uint32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetRTPCValue(UInt32, UnityEngine.GameObject, UInt32, Single ByRef, Int32 ByRef) declare in AkSoundEngine
bool w_i4u4ou4Pr4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4ou4Pr4Pi4");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!apis->is_object(env, _sv3)) return false;
        if (!apis->is_object(env, _sv4)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
             
    // LuaValToCSVal P primitive
    float up3 = 0;
    if (3 < lua_args_len)
        up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv3);
    float* p3 = &up3;
     
    // LuaValToCSVal P primitive
    int32_t up4 = 0;
    if (4 < lua_args_len)
        up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv4);
    int32_t* p4 = &up4;

    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, uint32_t p3, float* p4, int32_t* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret3 = converter::Converter<float>::toScript(apis, env, *p3);
	int ret4 = converter::Converter<int32_t>::toScript(apis, env, *p4);
	apis->add_return(info, r);
	apis->add_return(info, ret3);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetImageSource(UInt32, AkImageSourceSettings, UInt32, UInt64, UnityEngine.GameObject) declare in AkSoundEngine
bool w_i4u4ou4u8o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4ou4u8o");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv3))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint64_t p3 = converter::Converter<uint64_t>::toCpp(apis, env, _sv3);
            
    // LuaValToCSVal o/O
    Il2CppObject* p4 = LuaValueToCSRef(apis, TIp4, env, _sv4);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, Il2CppObject* p2, uint32_t p3, uint64_t p4, Il2CppObject* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT UnloadBank(UInt32, IntPtr) declare in AkSoundEngine
bool w_i4u4p(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4p");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT UnloadBank(UInt32, IntPtr, BankCallback, System.Object) declare in AkSoundEngine
bool w_i4u4poO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4poO");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_binary(env, _sv1) && !apis->is_null(env, _sv1) && !apis->is_undefined(env, _sv1)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, void* p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValue(UInt32, Single) declare in AkSoundEngine
bool w_i4u4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT Seek(UInt32, Single, Boolean) declare in AkSoundEngine
bool w_i4u4r4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4r4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, float p2, bool p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValue(UInt32, Single, UnityEngine.GameObject) declare in AkSoundEngine
bool w_i4u4r4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4r4o");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, float p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValue(UInt32, Single, UnityEngine.GameObject, Int32) declare in AkSoundEngine
bool w_i4u4r4oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4r4oi4");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, float p2, Il2CppObject* p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValue(UInt32, Single, UnityEngine.GameObject, Int32, AkCurveInterpolation) declare in AkSoundEngine
bool w_i4u4r4oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4r4oi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, float p2, Il2CppObject* p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValue(UInt32, Single, UnityEngine.GameObject, Int32, AkCurveInterpolation, Boolean) declare in AkSoundEngine
bool w_i4u4r4oi4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4r4oi4i4b");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, float p2, Il2CppObject* p3, int32_t p4, int32_t p5, bool p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValueByPlayingID(UInt32, Single, UInt32) declare in AkSoundEngine
bool w_i4u4r4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4r4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, float p2, uint32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValueByPlayingID(UInt32, Single, UInt32, Int32) declare in AkSoundEngine
bool w_i4u4r4u4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4r4u4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, float p2, uint32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValueByPlayingID(UInt32, Single, UInt32, Int32, AkCurveInterpolation) declare in AkSoundEngine
bool w_i4u4r4u4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4r4u4i4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, float p2, uint32_t p3, int32_t p4, int32_t p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRTPCValueByPlayingID(UInt32, Single, UInt32, Int32, AkCurveInterpolation, Boolean) declare in AkSoundEngine
bool w_i4u4r4u4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4r4u4i4i4b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(apis, env, _sv5);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, float p2, uint32_t p3, int32_t p4, int32_t p5, bool p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetState(UInt32, UInt32) declare in AkSoundEngine
bool w_i4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, uint32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetDialogueEventCustomPropertyValue(UInt32, UInt32, Int32 ByRef) declare in AkSoundEngine
bool w_i4u4u4Pi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4u4Pi4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal P primitive
    int32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(apis, env, _sv2);
    int32_t* p2 = &up2;

    typedef int32_t (*FuncToCall)(uint32_t p1, uint32_t p2, int32_t* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret2 = converter::Converter<int32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetDialogueEventCustomPropertyValue(UInt32, UInt32, Single ByRef) declare in AkSoundEngine
bool w_i4u4u4Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4u4Pr4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal P primitive
    float up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv2);
    float* p2 = &up2;

    typedef int32_t (*FuncToCall)(uint32_t p1, uint32_t p2, float* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret2 = converter::Converter<float>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT GetDeviceList(UInt32, UInt32, UInt32 ByRef, AkDeviceDescriptionArray) declare in AkSoundEngine
bool w_i4u4u4Pu4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4u4Pu4o");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!apis->is_object(env, _sv2)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
             
    // LuaValToCSVal P primitive
    uint32_t up2 = 0;
    if (2 < lua_args_len)
        up2 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(apis, env, _sv2);
    uint32_t* p2 = &up2;
    
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, uint32_t p2, uint32_t* p3, Il2CppObject* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret2 = converter::Converter<uint32_t>::toScript(apis, env, *p2);
	apis->add_return(info, r);
	apis->add_return(info, ret2);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetSwitch(UInt32, UInt32, UnityEngine.GameObject) declare in AkSoundEngine
bool w_i4u4u4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4u4o");
    AutoValueScope value_scope(apis, env);
    auto TIp2 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, uint32_t p2, Il2CppObject* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetActorMixerEffect(UInt32, UInt32, UInt32) declare in AkSoundEngine
bool w_i4u4u4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4u4u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint32_t p1, uint32_t p2, uint32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// CannotEquipReason CanWearToHero(UInt32, UInt32, UInt32, ResData.ResEquipDataBin ByRef, Boolean, Boolean) declare in Assets.Scripts.GameLogic.EquipUtil
bool w_i4u4u4u4PobDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4u4u4PobDb");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 5 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!apis->is_object(env, _sv3)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
             // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
         // LuaValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef int32_t (*FuncToCall)(uint32_t p1, uint32_t p2, uint32_t p3, Il2CppObject** p4, bool p5, bool p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret3 = CSRefToLuaValue(apis, env, TIp3, *p3);
	apis->add_return(info, r);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// CannotEquipReason CanWearToHeroNoCheckCount(UInt32, UInt32, UInt32, System.Collections.Generic.List`1[Assets.Scripts.GameLogic.Project8EquipDetailInfo], ResData.ResEquipDataBin ByRef, Boolean) declare in Assets.Scripts.GameLogic.EquipUtil
bool w_i4u4u4u4oPoDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u4u4u4oPoDb");
    AutoValueScope value_scope(apis, env);
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 5 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!apis->is_object(env, _sv4)) return false;
        if (lua_args_len > 5 && !converter::Converter<bool>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
             // LuaValToCSVal Po/PO
    Il2CppObject* up4 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv4)); // object ret
    Il2CppObject** p4 = &up4;
         // LuaValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef int32_t (*FuncToCall)(uint32_t p1, uint32_t p2, uint32_t p3, Il2CppObject* p4, Il2CppObject** p5, bool p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret4 = CSRefToLuaValue(apis, env, TIp4, *p4);
	apis->add_return(info, r);
	apis->add_return(info, ret4);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32 ToInt32(UInt64) declare in System.Convert
bool w_i4u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef int32_t (*FuncToCall)(uint64_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT QueryWetDiffraction(UInt64, Single ByRef) declare in AkSoundEngine
bool w_i4u8Pr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u8Pr4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
             
    // LuaValToCSVal P primitive
    float up1 = 0;
    if (1 < lua_args_len)
        up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(apis, env, _sv1);
    float* p1 = &up1;

    typedef int32_t (*FuncToCall)(uint64_t p1, float* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	int ret1 = converter::Converter<float>::toScript(apis, env, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRoomPortal(UInt64, AkTransform, UnityEngine.Vector3, Boolean, UInt64, UInt64) declare in AkSoundEngine
bool w_i4u8oS_r4r4r4_bu8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u8oS_r4r4r4_bu8u8");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
             // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    uint64_t p4 = converter::Converter<uint64_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    uint64_t p5 = converter::Converter<uint64_t>::toCpp(apis, env, _sv5);
        
    typedef int32_t (*FuncToCall)(uint64_t p1, Il2CppObject* p2, struct S_r4r4r4_ p3, bool p4, uint64_t p5, uint64_t p6, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetRoom(UInt64, AkRoomParams, System.String) declare in AkSoundEngine
bool w_i4u8os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u8os");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef int32_t (*FuncToCall)(uint64_t p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetGeometry(UInt64, AkTriangleArray, UInt32, UnityEngine.Vector3[], UInt32, AkAcousticSurfaceArray, UInt32, UInt64, Boolean, Boolean) declare in AkSoundEngine
bool w_i4u8ou4ou4ou4u8bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u8ou4ou4ou4u8bb");
    AutoValueScope value_scope(apis, env);
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    int _sv9 = apis->get_arg(info, 9);
    if (checkLuaArgument) {
        if (lua_args_len != 10) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv5, TIp5, false))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<uint64_t>::accept(apis, env, _sv7))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv9))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
                
    // LuaValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(apis, env, _sv4);
            
    // LuaValToCSVal o/O
    Il2CppObject* p5 = LuaValueToCSRef(apis, TIp5, env, _sv5);
                
    // LuaValToCSVal P any
    uint32_t p6 = converter::Converter<uint32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    uint64_t p7 = converter::Converter<uint64_t>::toCpp(apis, env, _sv7);
                
    // LuaValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
                
    // LuaValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(apis, env, _sv9);
        
    typedef int32_t (*FuncToCall)(uint64_t p1, Il2CppObject* p2, uint32_t p3, Il2CppObject* p4, uint32_t p5, Il2CppObject* p6, uint32_t p7, uint64_t p8, bool p9, bool p10, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetOutputVolume(UInt64, Single) declare in AkSoundEngine
bool w_i4u8r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u8r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef int32_t (*FuncToCall)(uint64_t p1, float p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// AKRESULT SetPortalObstructionAndOcclusion(UInt64, Single, Single) declare in AkSoundEngine
bool w_i4u8r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i4u8r4r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef int32_t (*FuncToCall)(uint64_t p1, float p2, float p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int32_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 GetCurUnixTimestampMilliseconds() declare in Utility
bool w_i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef int64_t (*FuncToCall)(const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(System.Object) declare in System.Convert
bool w_i8O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8O");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef int64_t (*FuncToCall)(Il2CppObject* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(System.Object, System.IFormatProvider) declare in System.Convert
bool w_i8Oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8Oo");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef int64_t (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 DotLong(VInt2 ByRef, VInt2 ByRef) declare in VInt2
bool w_i8PS_i4i4_PS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8PS_i4i4_PS_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_i4i4_* p0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_i4i4_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
             
    // LuaValToCSVal Pstruct
    S_i4i4_* p1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_i4i4_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
        
    typedef int64_t (*FuncToCall)(struct S_i4i4_* p1, struct S_i4i4_* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }
                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 DotLong(VInt2, VInt2) declare in VInt2
bool w_i8S_i4i4_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_i4i4_S_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
             // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef int64_t (*FuncToCall)(struct S_i4i4_ p1, struct S_i4i4_ p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(System.Decimal) declare in System.Convert
bool w_i8S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef int64_t (*FuncToCall)(struct S_i4i4i4i4u8_ p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(System.DateTime) declare in System.Convert
bool w_i8S_u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8S_u8_");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u8_* pp0 = DataTransfer::GetPointer<S_u8_>(apis, env, _sv0);
    S_u8_ p0 = pp0 ? *pp0 : S_u8_ {};
        
    typedef int64_t (*FuncToCall)(struct S_u8_ p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(Boolean) declare in System.Convert
bool w_i8b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8b");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef int64_t (*FuncToCall)(bool p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(Char) declare in System.Convert
bool w_i8c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8c");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef int64_t (*FuncToCall)(Il2CppChar p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(SByte) declare in System.Convert
bool w_i8i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8i1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef int64_t (*FuncToCall)(int8_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(Int16) declare in System.Convert
bool w_i8i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8i2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef int64_t (*FuncToCall)(int16_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(Int32) declare in System.Convert
bool w_i8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef int64_t (*FuncToCall)(int32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(Int64) declare in System.Convert
bool w_i8i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8i8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
        
    typedef int64_t (*FuncToCall)(int64_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 GetDailyRemianSeconds(Int64, Int32, Int32) declare in Utility
bool w_i8i8i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8i8i4i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef int64_t (*FuncToCall)(int64_t p1, int32_t p2, int32_t p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(Single) declare in System.Convert
bool w_i8r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8r4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
        
    typedef int64_t (*FuncToCall)(float p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(Double) declare in System.Convert
bool w_i8r8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8r8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<double>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(apis, env, _sv0);
        
    typedef int64_t (*FuncToCall)(double p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToNumber(System.String) declare in VersionInfo
bool w_i8s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8s");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef int64_t (*FuncToCall)(Il2CppString* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(System.String, Int32) declare in System.Convert
bool w_i8si4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8si4");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef int64_t (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 GetLong(System.String, Int64) declare in PlayerPrefsX
bool w_i8si8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8si8");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
        
    typedef int64_t (*FuncToCall)(Il2CppString* p1, int64_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(System.String, System.IFormatProvider) declare in System.Convert
bool w_i8so(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8so");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef int64_t (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ExtGetLocalFileId(UnityEngine.Component) declare in ExtComponent
bool w_i8t(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8t");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef int64_t (*FuncToCall)(void*,const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 GetLongLength(Int32) declare in System.Array
bool w_i8ti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8ti4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef int64_t (*FuncToCall)(void*,int32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 Seek(Int64, System.IO.SeekOrigin) declare in Ionic.Zlib.ZlibStream
bool w_i8ti8i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8ti8i4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int64_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef int64_t (*FuncToCall)(void*,int64_t p1, int32_t p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 GetFileLength(System.String) declare in Assets.Scripts.Common.UploaderAux
bool w_i8ts(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8ts");
    AutoValueScope value_scope(apis, env);
    auto TIp0 = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef int64_t (*FuncToCall)(void*,Il2CppString* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(Byte) declare in System.Convert
bool w_i8u1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8u1");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(apis, env, _sv0);
        
    typedef int64_t (*FuncToCall)(uint8_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(UInt16) declare in System.Convert
bool w_i8u2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8u2");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(apis, env, _sv0);
        
    typedef int64_t (*FuncToCall)(uint16_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(UInt32) declare in System.Convert
bool w_i8u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8u4");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(apis, env, _sv0);
        
    typedef int64_t (*FuncToCall)(uint32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int64 ToInt64(UInt64) declare in System.Convert
bool w_i8u8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_i8u8");
    AutoValueScope value_scope(apis, env);

    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<uint64_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(apis, env, _sv0);
        
    typedef int64_t (*FuncToCall)(uint64_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = converter::Converter<int64_t>::toScript(apis, env, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] GetBuildTags() declare in UnityEngine.Application
bool w_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef Il2CppObject* (*FuncToCall)(const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTSeq sequence(Boolean) declare in LeanTween
bool w_oDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef Il2CppObject* (*FuncToCall)(bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// IReadOnlyList`1[ResData.ResChessHeroConfDataBin] GetMultiHeroesList(Int32) declare in PBData.PBDataAux
bool w_oDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr[] descriptions(UnityEngine.GameObject) declare in LeanTween
bool w_oDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    // LuaValToCSVal ref with default
    Il2CppObject* p0 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 0, TIp0);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// os_ai.FrameState deserialize_os_ai_FrameState(Byte* ByRef) declare in SGW
bool w_oPPu1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oPPu1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
 
    // LuaValToCSVal P not primitive
    uint8_t** p0 = nullptr;

    typedef Il2CppObject* (*FuncToCall)(uint8_t** p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	int ret0 = converter::Converter<std::reference_wrapper<uint8_t>>::toScript(apis, env, **p0);
	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.Player GetOwnerPlayer(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker] ByRef) declare in Assets.Scripts.GameLogic.ActorHelper
bool w_oPS_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oPS_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4o_* p0 = DataTransfer::GetPointer<S_u4o_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4o_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef Il2CppObject* (*FuncToCall)(struct S_u4o_* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.AsyncOperation MoveMainWindowTo(UnityEngine.DisplayInfo ByRef, UnityEngine.Vector2Int) declare in UnityEngine.Screen
bool w_oPS_u8i4i4S_u4u4_S_i4i4i4i4_s_S_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oPS_u8i4i4S_u4u4_S_i4i4i4i4_s_S_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u8i4i4S_u4u4_S_i4i4i4i4_s_* p0 = DataTransfer::GetPointer<S_u8i4i4S_u4u4_S_i4i4i4i4_s_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u8i4i4S_u4u4_S_i4i4i4i4_s_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
             // LuaValToCSVal struct
    S_i4i4_* pp1 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv1);
    S_i4i4_ p1 = pp1 ? *pp1 : S_i4i4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(struct S_u8i4i4S_u4u4_S_i4i4i4i4_s_* p1, struct S_i4i4_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UILuaPrefabClass LuaPrefabCreateOrSetVisible(Assets.Scripts.Framework.UI.UILuaPrefabClass ByRef, System.String, Boolean) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_oPosb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oPosb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal Po/PO
    Il2CppObject* up0 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv0)); // object ret
    Il2CppObject** p0 = &up0;
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject** p1, Il2CppString* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	int ret0 = CSRefToLuaValue(apis, env, TIp0, *p0);
	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetTypeFromCLSID(System.Guid) declare in System.Type
bool w_oS_i4i2i2u1u1u1u1u1u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i2i2u1u1u1u1u1u1u1u1_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
        
    typedef Il2CppObject* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetTypeFromCLSID(System.Guid, Boolean) declare in System.Type
bool w_oS_i4i2i2u1u1u1u1u1u1u1u1_b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i2i2u1u1u1u1u1u1u1u1_b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetTypeFromCLSID(System.Guid, System.String) declare in System.Type
bool w_oS_i4i2i2u1u1u1u1u1u1u1u1_s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i2i2u1u1u1u1u1u1u1u1_s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppObject* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetTypeFromCLSID(System.Guid, System.String, Boolean) declare in System.Type
bool w_oS_i4i2i2u1u1u1u1u1u1u1u1_sb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i2i2u1u1u1u1u1u1u1u1_sb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<S_i4i2i2u1u1u1u1u1u1u1u1_>(apis, env, _sv0);
    S_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : S_i4i2i2u1u1u1u1u1u1u1u1_ {};
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(struct S_i4i2i2u1u1u1u1u1u1u1u1_ p1, Il2CppString* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.RenderTexture GetTemporary(UnityEngine.RenderTextureDescriptor) declare in UnityEngine.RenderTexture
bool w_oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oS_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(apis, env, _sv0);
    S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(struct S_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetTypeFromHandle(System.RuntimeTypeHandle) declare in System.Type
bool w_oS_p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oS_p_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};
        
    typedef Il2CppObject* (*FuncToCall)(struct S_p_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.FieldInfo GetFieldFromHandle(System.RuntimeFieldHandle, System.RuntimeTypeHandle) declare in System.Reflection.FieldInfo
bool w_oS_p_S_p_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oS_p_S_p_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_p_* pp0 = DataTransfer::GetPointer<S_p_>(apis, env, _sv0);
    S_p_ p0 = pp0 ? *pp0 : S_p_ {};
             // LuaValToCSVal struct
    S_p_* pp1 = DataTransfer::GetPointer<S_p_>(apis, env, _sv1);
    S_p_ p1 = pp1 ? *pp1 : S_p_ {};
        
    typedef Il2CppObject* (*FuncToCall)(struct S_p_ p1, struct S_p_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// XLua.LuaTable FindLordInThere(UnityEngine.Vector2) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_oS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(struct S_r4r4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.Project8PlayerInstance GetPlayerInstance(PooledCollections.PoolObjHandle`1[Assets.Scripts.GameLogic.ActorLinker]) declare in Assets.Scripts.GameLogic.PlayerUtil
bool w_oS_u4o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oS_u4o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_u4o_* pp0 = DataTransfer::GetPointer<S_u4o_>(apis, env, _sv0);
    S_u4o_ p0 = pp0 ? *pp0 : S_u4o_ {};
        
    typedef Il2CppObject* (*FuncToCall)(struct S_u4o_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.AsyncOperation RequestUserAuthorization(UnityEngine.UserAuthorization) declare in UnityEngine.Application
bool w_oi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[ResData.ResCardKeywordDescDataBin] GetDescription(Int32, System.Collections.Generic.Dictionary`2[System.Int32,OSProto.CardDescReplaceInfo]) declare in Assets.Scripts.UI.InTheGame.Standard.CardKeywordDescHelper
bool w_oi4Do(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4Do");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Light[] GetLights(UnityEngine.LightType, Int32) declare in UnityEngine.Light
bool w_oi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Texture2D CreateTexture(Int32, Int32, UnityEngine.Color) declare in com.pixui.PxMisc
bool w_oi4i4S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, int32_t p2, struct S_r4r4r4r4_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32) declare in UnityEngine.RenderTexture
bool w_oi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat) declare in UnityEngine.RenderTexture
bool w_oi4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32) declare in UnityEngine.RenderTexture
bool w_oi4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, UnityEngine.RenderTextureMemoryless) declare in UnityEngine.RenderTexture
bool w_oi4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (checkLuaArgument) {
        if (lua_args_len != 6) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
        
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage) declare in UnityEngine.RenderTexture
bool w_oi4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4i4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    if (checkLuaArgument) {
        if (lua_args_len != 7) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
        
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage, Boolean) declare in UnityEngine.RenderTexture
bool w_oi4i4i4i4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4i4i4i4b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv7))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(apis, env, _sv7);
        
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage) declare in UnityEngine.RenderTexture
bool w_oi4i4i4i4i4i4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4i4i4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    if (checkLuaArgument) {
        if (lua_args_len != 8) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
        
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage, Boolean) declare in UnityEngine.RenderTexture
bool w_oi4i4i4i4i4i4i4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4i4i4i4i4i4i4b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    int _sv6 = apis->get_arg(info, 6);
    int _sv7 = apis->get_arg(info, 7);
    int _sv8 = apis->get_arg(info, 8);
    if (checkLuaArgument) {
        if (lua_args_len != 9) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv6))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv7))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv8))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(apis, env, _sv4);
                
    // LuaValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(apis, env, _sv5);
                
    // LuaValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(apis, env, _sv6);
                
    // LuaValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(apis, env, _sv7);
                
    // LuaValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(apis, env, _sv8);
        
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, bool p9, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[System.String] GetBattlePreloadMaterialList(Int32, Int32, System.String) declare in LuaCallCSharpInteraction
bool w_oi4i4s(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4i4s");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, int32_t p2, Il2CppString* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// com.pixui.PxWindow CreateWindow(Int32, com.pixui.MountUI) declare in com.pixui.PxContext
bool w_oi4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Token SetTimer(Int32, System.Action, System.Action) declare in com.pixui.PxContext
bool w_oi4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[Assets.Scripts.GameLogic.Project8PreLoadConfig+Project8FormatPreLoadPrefabConfig] GetPreloadParticleList(Int32, UInt32) declare in LuaCallCSharpInteraction
bool w_oi4u4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oi4u4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(int32_t p1, uint32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// DataBase GetDataByType(System.Type) declare in DataService
bool w_oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UIPrefabBaseClass CreatePrefabClass(System.Type, System.Object) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_ooDO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooDO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[ResData.ResCardKeywordDescDataBin] GetDescription(ResData.ResCardInfoDataBin, System.Collections.Generic.Dictionary`2[System.Int32,OSProto.CardDescReplaceInfo]) declare in Assets.Scripts.UI.InTheGame.Standard.CardKeywordDescHelper
bool w_ooDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UICommonEquipDetailTipData GetEquipProductTipsData(stShowEquipmentInfo, EquipRecommendRet ByRef, Boolean, Boolean) declare in Assets.Scripts.GameLogic.EquipUtil
bool w_ooPS_u4o_bb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooPS_u4o_bb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             
    // LuaValToCSVal Pstruct
    S_u4o_* p1 = DataTransfer::GetPointer<S_u4o_>(apis, env, apis->unboxing(env, _sv1)); // valuetype ref
    S_u4o_ up1;
    if (!p1) {
        memset(&up1, 0, sizeof(p1));
        p1 = &up1;
    }
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_u4o_* p2, bool p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);                
    int ret1;
    if (p1 == &up1)
    {
        ret1 = DataTransfer::CopyValueType(apis, env, *p1, TIp1);    
        apis->update_boxed_value(env, _sv1, ret1);
    }
    else
    {
        ret1 = apis->native_object_to_value(env, TIp1, p1, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] GetEnumDescriptions(System.Type, System.String[] ByRef) declare in Assets.Scripts.UI.NewbieUtils
bool w_ooPo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooPo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!apis->is_object(env, _sv1)) return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal Po/PO
    Il2CppObject* up1 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv1)); // object ret
    Il2CppObject** p1 = &up1;
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject** p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	int ret1 = CSRefToLuaValue(apis, env, TIp1, *p1);
	apis->add_return(info, r);
	apis->add_return(info, ret1);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(UnityEngine.GameObject, UnityEngine.Vector2, UnityEngine.Vector2, Single) declare in LeanTween
bool w_ooS_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4_S_r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, struct S_r4r4_ p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr move(UnityEngine.GameObject, UnityEngine.Vector2, Single) declare in LeanTween
bool w_ooS_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3[] add(UnityEngine.Vector3[], UnityEngine.Vector3) declare in LeanTween
bool w_ooS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(UnityEngine.GameObject, UnityEngine.Vector3, UnityEngine.Vector3, Single) declare in LeanTween
bool w_ooS_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4_S_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4r4_ p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Vector3, UnityEngine.Quaternion) declare in UnityEngine.Object
bool w_ooS_r4r4r4_S_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4_S_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Transform) declare in UnityEngine.Object
bool w_ooS_r4r4r4_S_r4r4r4r4_o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4_S_r4r4r4r4_o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, struct S_r4r4r4r4_ p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr move(UnityEngine.GameObject, UnityEngine.Vector3, Single) declare in LeanTween
bool w_ooS_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.GameObject TestRayCast(UnityEngine.Camera, UnityEngine.Vector3, Single, Int32) declare in LuaCallCSharpInteraction
bool w_ooS_r4r4r4_r4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4_r4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, float p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr rotateAround(UnityEngine.GameObject, UnityEngine.Vector3, Single, Single) declare in LeanTween
bool w_ooS_r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4_r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4_ p2, float p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(UnityEngine.GameObject, UnityEngine.Color, UnityEngine.Color, Single) declare in LeanTween
bool w_ooS_r4r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_S_r4r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4r4_ p2, struct S_r4r4r4r4_ p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr color(UnityEngine.GameObject, UnityEngine.Color, Single) declare in LeanTween
bool w_ooS_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooS_r4r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, struct S_r4r4r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Array CreateInstance(System.Type, Int32[]) declare in System.Array
bool w_ooVi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooVi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        if(lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             
    // LuaValToCSVal primitive params
    Il2CppArray* p1 = Params<int32_t>::PackPrimitive(apis, env, info, TIp1, lua_args_len, 1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Array CreateInstance(System.Type, Int64[]) declare in System.Array
bool w_ooVi8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooVi8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        if(lua_args_len > 1 && !converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
             
    // LuaValToCSVal primitive params
    Il2CppArray* p1 = Params<int64_t>::PackPrimitive(apis, env, info, TIp1, lua_args_len, 1);

    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type MakeGenericSignatureType(System.Type, System.Type[]) declare in System.Type
bool w_ooVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooVo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;        auto TIp1_V = il2cpp::vm::Class::GetElementClass(TIp1);if(lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1_V, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Object[] FindObjectsOfType(System.Type, Boolean) declare in UnityEngine.Object
bool w_oob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oob");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Object[] FindObjectsByType(System.Type, UnityEngine.FindObjectsSortMode) declare in UnityEngine.Object
bool w_ooi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Object[] FindObjectsByType(System.Type, UnityEngine.FindObjectsInactive, UnityEngine.FindObjectsSortMode) declare in UnityEngine.Object
bool w_ooi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte[] UrlEncode(Byte[], Int32, Int32, Boolean) declare in QCloud.CosApi.Util.HttpUtils
bool w_ooi4i4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Array CreateInstance(System.Type, Int32, Int32, Int32) declare in System.Array
bool w_ooi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte[] EncodeArrayToTGA(System.Array, UnityEngine.Experimental.Rendering.GraphicsFormat, UInt32, UInt32, UInt32) declare in UnityEngine.ImageConversion
bool w_ooi4u4u4Du4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4u4u4Du4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
         // LuaValToCSVal primitive with default
    uint32_t p4 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, uint32_t p3, uint32_t p4, uint32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Byte[] EncodeArrayToJPG(System.Array, UnityEngine.Experimental.Rendering.GraphicsFormat, UInt32, UInt32, UInt32, Int32) declare in UnityEngine.ImageConversion
bool w_ooi4u4u4Du4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooi4u4u4Du4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 6) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<uint32_t>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<uint32_t>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<int32_t>::accept(apis, env, _sv5))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(apis, env, _sv3);
         // LuaValToCSVal primitive with default
    uint32_t p4 = OptionalParameter<uint32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
             // LuaValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, int32_t p2, uint32_t p3, uint32_t p4, uint32_t p5, int32_t p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr play(UnityEngine.RectTransform, UnityEngine.Sprite[]) declare in LeanTween
bool w_ooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.IEnumerator OpenEquipTip(Assets.Scripts.Framework.UI.UIPrefab2DClass, stShowEquipmentInfo, System.Action, Boolean, System.Action`1[PooledCollections.PoolObjHandle`1[Assets.Scripts.Framework.UI.UIPrefab2DClass]]) declare in Assets.Scripts.GameLogic.EquipUtil
bool w_oooDoDbDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oooDoDbDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2); // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
                // LuaValToCSVal ref with default
    Il2CppObject* p4 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 4, TIp4);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, Il2CppObject* p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(UnityEngine.GameObject, System.Action`1[UnityEngine.Vector2], UnityEngine.Vector2, UnityEngine.Vector2, Single) declare in LeanTween
bool w_oooS_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oooS_r4r4_S_r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
             // LuaValToCSVal struct
    S_r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv2);
    S_r4r4_ p2 = pp2 ? *pp2 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv3);
    S_r4r4_ p3 = pp3 ? *pp3 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_r4r4_ p3, struct S_r4r4_ p4, float p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(UnityEngine.GameObject, System.Action`1[UnityEngine.Vector3], UnityEngine.Vector3, UnityEngine.Vector3, Single) declare in LeanTween
bool w_oooS_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oooS_r4r4r4_S_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
             // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv3);
    S_r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_r4r4r4_ p3, struct S_r4r4r4_ p4, float p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr delayedSound(UnityEngine.GameObject, UnityEngine.AudioClip, UnityEngine.Vector3, Single) declare in LeanTween
bool w_oooS_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oooS_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
             // LuaValToCSVal struct
    S_r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv2);
    S_r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_r4r4r4_ p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(UnityEngine.GameObject, System.Action`1[UnityEngine.Color], UnityEngine.Color, UnityEngine.Color, Single) declare in LeanTween
bool w_oooS_r4r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oooS_r4r4r4r4_S_r4r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp2 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv2);
    S_r4r4r4r4_ p2 = pp2 ? *pp2 : S_r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp3 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv3);
    S_r4r4r4r4_ p3 = pp3 ? *pp3 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, struct S_r4r4r4r4_ p3, struct S_r4r4r4r4_ p4, float p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Transform, Boolean) declare in UnityEngine.Object
bool w_ooob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooob");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Array CreateInstance(System.Type, Int32[], Int32[]) declare in System.Array
bool w_oooo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oooo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr move(UnityEngine.GameObject, UnityEngine.Vector3[], Single) declare in LeanTween
bool w_ooor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooor4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(UnityEngine.GameObject, System.Action`1[System.Single], Single, Single, Single) declare in LeanTween
bool w_ooor4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooor4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv4))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(apis, env, _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, float p3, float p4, float p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// com.pixui.PxWindow LoadPageFromData(com.pixui.MountUI, Byte[], System.String) declare in com.pixui.PxContext
bool w_ooos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooos");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppObject* p2, Il2CppString* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr destroyAfter(LTRect, Single) declare in LeanTween
bool w_oor4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oor4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr delayedCall(UnityEngine.GameObject, Single, System.Action) declare in LeanTween
bool w_oor4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oor4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, float p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr alpha(UnityEngine.GameObject, Single, Single) declare in LeanTween
bool w_oor4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oor4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, float p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(UnityEngine.GameObject, Single, Single, Single) declare in LeanTween
bool w_oor4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oor4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv3))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, float p2, float p3, float p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.GameObject FindChildByName(UnityEngine.GameObject, System.String) declare in Utility
bool w_oos(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oos");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.GameObject CreateSceneGroupChildGameobject(UnityEngine.GameObject, System.String, Int32) declare in LuaCallCSharpInteraction
bool w_oosi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oosi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// com.pixui.PxWindow LoadString(com.pixui.MountUI, System.String, System.String) declare in com.pixui.PxContext
bool w_ooss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ooss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, false))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv2))
            return false;        
    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal s
    Il2CppString* p2 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv2);
    typedef Il2CppObject* (*FuncToCall)(Il2CppObject* p1, Il2CppString* p2, Il2CppString* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Token SetTimer(Single, Int32, System.Action) declare in com.pixui.PxContext
bool w_or4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_or4i4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(float p1, int32_t p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Token SetTimer(Single, Int32, System.Action, System.Action) declare in com.pixui.PxContext
bool w_or4i4oo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_or4i4oo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(float p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr delayedCall(Single, System.Action) declare in LeanTween
bool w_or4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_or4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(float p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr value(Single, Single, Single) declare in LeanTween
bool w_or4r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_or4r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<float>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(float p1, float p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.AsyncOperation LoadLevelAsync(System.String) declare in UnityEngine.Application
bool w_os(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_os");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UILuaPrefabClass CreateLuaPrefabClass(System.String, System.Object) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_osDO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osDO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.UI.UILuaPrefabClass AsyncCreateLuaPrefabClass(System.String, System.Object, System.Action`1[Assets.Scripts.Framework.UI.UILuaPrefabClass]) declare in Assets.Scripts.Framework.UI.UIUtility
bool w_osDODo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osDODo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal ref with default
    Il2CppObject* p1 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 1, TIp1);    // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Threading.Tasks.Task`1[System.String] ReadAllTextAsync(System.String, System.Threading.CancellationToken) declare in System.IO.File
bool w_osDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osDS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal valuetype with default
    S_o_ p1 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, struct S_o_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.CActorInfo GetActorInfo(System.String, Boolean) declare in Assets.Scripts.GameLogic.CActorInfo
bool w_osDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// CResource Load(System.String, ResourceLoaderStyle, System.Type, Boolean, BakedResourceType) declare in CResourceManager
bool w_osDi1DoDbDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osDi1DoDbDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0); // LuaValToCSVal primitive with default
    int8_t p1 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
                // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2); // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, int8_t p2, Il2CppObject* p3, bool p4, int32_t p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector2[] GetVector2Array(System.String, UnityEngine.Vector2, Int32) declare in PlayerPrefsX
bool w_osS_r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osS_r4r4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, struct S_r4r4_ p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Vector3[] GetVector3Array(System.String, UnityEngine.Vector3, Int32) declare in PlayerPrefsX
bool w_osS_r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osS_r4r4r4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4_ p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Quaternion[] GetQuaternionArray(System.String, UnityEngine.Quaternion, Int32) declare in PlayerPrefsX
bool w_osS_r4r4r4r4_i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osS_r4r4r4r4_i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);     // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, struct S_r4r4r4r4_ p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetTypeFromProgID(System.String, Boolean) declare in System.Type
bool w_osb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetType(System.String, Boolean, Boolean) declare in System.Type
bool w_osbb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osbb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, bool p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Boolean[] GetBoolArray(System.String, Boolean, Int32) declare in PlayerPrefsX
bool w_osbi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osbi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, bool p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileStream Create(System.String, Int32) declare in System.IO.File
bool w_osi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileStream Create(System.String, Int32, System.IO.FileOptions) declare in System.IO.File
bool w_osi4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osi4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileStream Open(System.String, System.IO.FileMode, System.IO.FileAccess, System.IO.FileShare) declare in System.IO.File
bool w_osi4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osi4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileStream Create(System.String, Int32, System.IO.FileOptions, System.Security.AccessControl.FileSecurity) declare in System.IO.File
bool w_osi4i4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osi4i4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, int32_t p2, int32_t p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] ReadAllLines(System.String, System.Text.Encoding) declare in System.IO.File
bool w_oso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oso");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Threading.Tasks.Task`1[System.String] ReadAllTextAsync(System.String, System.Text.Encoding, System.Threading.CancellationToken) declare in System.IO.File
bool w_osoDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osoDS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal valuetype with default
    S_o_ p2 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, struct S_o_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Timi.TimiMenuItem CreateItem(System.String, UnityEngine.Transform, System.Collections.Generic.List`1[Timi.TimiNestedPrefabOverrideProperty]) declare in Timi.TimiMenu
bool w_osoDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osoDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// CResource GetResource(System.String, System.Type, enResourceType, Boolean, enResourceLoadType, ResourceLoaderStyle) declare in CResourceManager
bool w_osoi4DbDi4Di1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osoi4DbDi4Di1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;
        if (lua_args_len > 5 && !converter::Converter<int8_t>::accept(apis, env, _sv5))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
         // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
             // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
             // LuaValToCSVal primitive with default
    int8_t p5 = OptionalParameter<int8_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 5);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, int32_t p3, bool p4, int32_t p5, int8_t p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetType(System.String, System.Func`2[System.Reflection.AssemblyName,System.Reflection.Assembly], System.Func`4[System.Reflection.Assembly,System.String,System.Boolean,System.Type]) declare in System.Type
bool w_osoo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osoo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Threading.Tasks.Task WriteAllLinesAsync(System.String, System.Collections.Generic.IEnumerable`1[System.String], System.Text.Encoding, System.Threading.CancellationToken) declare in System.IO.File
bool w_osooDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osooDS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            // LuaValToCSVal valuetype with default
    S_o_ p3 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, struct S_o_ p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetType(System.String, System.Func`2[System.Reflection.AssemblyName,System.Reflection.Assembly], System.Func`4[System.Reflection.Assembly,System.String,System.Boolean,System.Type], Boolean) declare in System.Type
bool w_osoob(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osoob");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetType(System.String, System.Func`2[System.Reflection.AssemblyName,System.Reflection.Assembly], System.Func`4[System.Reflection.Assembly,System.String,System.Boolean,System.Type], Boolean, Boolean) declare in System.Type
bool w_osoobb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osoobb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (checkLuaArgument) {
        if (lua_args_len != 5) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv3))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv4))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
                
    // LuaValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(apis, env, _sv3);
                
    // LuaValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(apis, env, _sv4);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, bool p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.IEnumerator PreInstantiate(System.String, Single) declare in Assets.Scripts.GameLogic.Hud3D
bool w_osr4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osr4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Single[] GetFloatArray(System.String, Single, Int32) declare in PlayerPrefsX
bool w_osr4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osr4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);        
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, float p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Sprite LoadSpriteImpl(System.String, System.String) declare in ExtImage
bool w_oss(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oss");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Threading.Tasks.Task WriteAllTextAsync(System.String, System.String, System.Threading.CancellationToken) declare in System.IO.File
bool w_ossDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ossDS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    // LuaValToCSVal valuetype with default
    S_o_ p2 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, struct S_o_ p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type GetTypeFromProgID(System.String, System.String, Boolean) declare in System.Type
bool w_ossb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ossb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] GetFiles(System.String, System.String, System.IO.SearchOption) declare in System.IO.Directory
bool w_ossi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ossi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.RegularExpressions.Match Match(System.String, System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan) declare in System.Text.RegularExpressions.Regex
bool w_ossi4S_i8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ossi4S_i8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
             // LuaValToCSVal struct
    S_i8_* pp3 = DataTransfer::GetPointer<S_i8_>(apis, env, _sv3);
    S_i8_ p3 = pp3 ? *pp3 : S_i8_ {};
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, int32_t p3, struct S_i8_ p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] GetFiles(System.String, System.String, System.IO.EnumerationOptions) declare in System.IO.Directory
bool w_osso(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_osso");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Threading.Tasks.Task WriteAllTextAsync(System.String, System.String, System.Text.Encoding, System.Threading.CancellationToken) declare in System.IO.File
bool w_ossoDS_o_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ossoDS_o_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !DataTransfer::IsAssignable(apis, env, _sv3, TIp3, true))
            return false;        
    }
    // LuaValToCSVal s
    Il2CppString* p0 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv0);    // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);    
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            // LuaValToCSVal valuetype with default
    S_o_ p3 = OptionalParameter<S_o_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef Il2CppObject* (*FuncToCall)(Il2CppString* p1, Il2CppString* p2, Il2CppObject* p3, struct S_o_ p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Texture2D ToTexture2D(UnityEngine.RenderTexture) declare in com.pixui.PxMisc
bool w_ot(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_ot");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);

    if (checkLuaArgument) {
        if (lua_args_len != 0) 
            return false;

    }

    typedef Il2CppObject* (*FuncToCall)(void*,const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Int32[] GetBattleHeroCfgIDs(Boolean) declare in Assets.Scripts.GameSystem.Project8UINewbie
bool w_otDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef Il2CppObject* (*FuncToCall)(void*,bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.FrontEndTimeline GetLordExTimeline(Int32) declare in Assets.Scripts.GameLogic.PlayerLordComponent
bool w_otDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (true) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;

        if (lua_args_len > 0 && !converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
 // LuaValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 0);
            
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr setOnCompleteParam(System.Object) declare in LTDescr
bool w_otO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

    }
    
    // LuaValToCSVal o/O
    Il2CppObject* p0 = LuaValueToCSRef(apis, TIp0, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppObject* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.InstantiatableAsset CreateGameObject(CreateUnityObject ByRef) declare in UnityObjMgr
bool w_otPS_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otPS_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_* p0 = DataTransfer::GetPointer<S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_u4S_S_u8_u4u4u4u4u4u1u1u1u1_u1u1u1_* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.ActorConfig CreateActor(SpawnActorData ByRef) declare in Assets.Scripts.GameLogic.ActorManager
bool w_otPS_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otPS_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;        
    }
     
    // LuaValToCSVal Pstruct
    S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_* p0 = DataTransfer::GetPointer<S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_>(apis, env, apis->unboxing(env, _sv0)); // valuetype ref
    S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_ up0;
    if (!p0) {
        memset(&up0, 0, sizeof(p0));
        p0 = &up0;
    }
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_u4u4u4u4u4u4u1u1u4u4S_r4r4r4_u4u2i2u1_* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);                
    int ret0;
    if (p0 == &up0)
    {
        ret0 = DataTransfer::CopyValueType(apis, env, *p0, TIp0);    
        apis->update_boxed_value(env, _sv0, ret0);
    }
    else
    {
        ret0 = apis->native_object_to_value(env, TIp0, p0, false);
    }

	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(Char*, Int32) declare in System.Text.StringBuilder
bool w_otPci4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otPci4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!apis->is_object(env, _sv0)) return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
     
    // LuaValToCSVal P primitive
    Il2CppChar up0 = 0x0;
    if (0 < lua_args_len)
        up0 = converter::Converter<std::reference_wrapper<Il2CppChar>>::toCpp(apis, env, _sv0);
    Il2CppChar* p0 = &up0;
        
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar* p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	int ret0 = converter::Converter<Il2CppChar>::toScript(apis, env, *p0);
	apis->add_return(info, r);
	apis->add_return(info, ret0);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(System.ReadOnlySpan`1[System.Char]) declare in System.Text.StringBuilder
bool w_otS_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_S_p_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_S_p_i4_* pp0 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv0);
    S_S_p_i4_ p0 = pp0 ? *pp0 : S_S_p_i4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_S_p_i4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.ChessAreaInfo GetBattleFieldSlotByCoord(VInt2) declare in Assets.Scripts.GameLogic.PlayerChessManager
bool w_otS_i4i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_i4i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4_* pp0 = DataTransfer::GetPointer<S_i4i4_>(apis, env, _sv0);
    S_i4i4_ p0 = pp0 ? *pp0 : S_i4i4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_i4i4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(System.Decimal) declare in System.Text.StringBuilder
bool w_otS_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp0 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv0);
    S_i4i4i4i4u8_ p0 = pp0 ? *pp0 : S_i4i4i4i4u8_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_i4i4i4i4u8_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.SceneInteractcs SceneInteraction(UnityEngine.Vector2) declare in Assets.Scripts.GameLogic.Project8SceneManagement
bool w_otS_r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, UnityEngine.Vector2, UnityEngine.Vector2, Single) declare in LeanTweenExt
bool w_otS_r4r4_S_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4_S_r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv1);
    S_r4r4_ p1 = pp1 ? *pp1 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4_ p1, struct S_r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanMove(UnityEngine.GameObject, UnityEngine.Vector2, Single) declare in LeanTweenExt
bool w_otS_r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4_>(apis, env, _sv0);
    S_r4r4_ p0 = pp0 ? *pp0 : S_r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4_ p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr setAxis(UnityEngine.Vector3) declare in LTDescr
bool w_otS_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, UnityEngine.Vector3, UnityEngine.Vector3, Single) declare in LeanTweenExt
bool w_otS_r4r4r4_S_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4_S_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4_ p1, struct S_r4r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanMove(UnityEngine.GameObject, UnityEngine.Vector3, Single) declare in LeanTweenExt
bool w_otS_r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4_ p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanRotateAround(UnityEngine.GameObject, UnityEngine.Vector3, Single, Single) declare in LeanTweenExt
bool w_otS_r4r4r4_r4r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4_r4r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv0);
    S_r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4_ p1, float p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr setFromColor(UnityEngine.Color) declare in LTDescr
bool w_otS_r4r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanValue(UnityEngine.GameObject, UnityEngine.Color, UnityEngine.Color, Single) declare in LeanTweenExt
bool w_otS_r4r4r4r4_S_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4r4_S_r4r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv2))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
             // LuaValToCSVal struct
    S_r4r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv1);
    S_r4r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, struct S_r4r4r4r4_ p2, float p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.IEnumerator Capture(UnityEngine.Rect, System.Action`1[System.String], System.Action`1[UnityEngine.Texture2D], System.String, Assets.Scripts.GameSystem.CaptureSettings) declare in Assets.Scripts.GameSystem.ShareCaptureSys
bool w_otS_r4r4r4r4_oDoDsDS_bbi4bo_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4r4_oDoDsDS_bbi4bo_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];
    auto TIp4 = wrapData->TypeInfos[5];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 5) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !DataTransfer::IsAssignable(apis, env, _sv4, TIp4, true))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);    // LuaValToCSVal string with default
    Il2CppString* p3 = OptionalParameter<Il2CppString*>::GetString(apis, env, info, method, wrapData, lua_args_len, 3);    // LuaValToCSVal valuetype with default
    S_bbi4bo_ p4 = OptionalParameter<S_bbi4bo_>::GetValueType(apis, env, info, method, wrapData, lua_args_len, 4);
            
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, Il2CppObject* p2, Il2CppObject* p3, Il2CppString* p4, struct S_bbi4bo_ p5, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr LeanColor(UnityEngine.GameObject, UnityEngine.Color, Single) declare in LeanTweenExt
bool w_otS_r4r4r4r4_r4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otS_r4r4r4r4_r4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!DataTransfer::IsAssignable(apis, env, _sv0, TIp0, true))
            return false;
        if (!converter::Converter<float>::accept(apis, env, _sv1))
            return false;        
    }
     // LuaValToCSVal struct
    S_r4r4r4r4_* pp0 = DataTransfer::GetPointer<S_r4r4r4r4_>(apis, env, _sv0);
    S_r4r4r4r4_ p0 = pp0 ? *pp0 : S_r4r4r4r4_ {};
                
    // LuaValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,struct S_r4r4r4r4_ p1, float p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] Split(Char[]) declare in System.String
bool w_otVc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otVc");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        if(lua_args_len > 0 && !converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
     
    // LuaValToCSVal primitive params
    Il2CppArray* p0 = Params<Il2CppChar>::PackPrimitive(apis, env, info, TIp0, lua_args_len, 0);

    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppArray* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Type MakeGenericType(System.Type[]) declare in System.Type
bool w_otVo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otVo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len < 0 || lua_args_len > 1) 
            return false;
        auto TIp0_V = il2cpp::vm::Class::GetElementClass(TIp0);if(lua_args_len > 0 && !DataTransfer::IsAssignable(apis, env, _sv0, TIp0_V, false))
            return false;        
    }
    // LuaValToCSVal ref params
    Il2CppArray* p0 = Params<void*>::PackRef(apis, env, info, TIp0, lua_args_len, 0);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppArray* p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// LTDescr setHasInitialized(Boolean) declare in LTDescr
bool w_otb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,bool p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Collections.Generic.List`1[Assets.Scripts.UI.InTheGame.Standard.UIRoundStateAwardItemData] GetAirdropIconList(Boolean, Int32, Int32, System.Collections.Generic.List`1[Assets.Scripts.UI.InTheGame.Standard.UIRoundStateAwardItemData] ByRef) declare in Assets.Scripts.GameLogic.Project8AirdropAwardLogic
bool w_otbi4i4Po(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otbi4i4Po");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!apis->is_object(env, _sv3)) return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
             // LuaValToCSVal Po/PO
    Il2CppObject* up3 = DataTransfer::GetPointer<Il2CppObject>(apis, env, apis->unboxing(env, _sv3)); // object ret
    Il2CppObject** p3 = &up3;
        
    typedef Il2CppObject* (*FuncToCall)(void*,bool p1, int32_t p2, int32_t p3, Il2CppObject** p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	int ret3 = CSRefToLuaValue(apis, env, TIp3, *p3);
	apis->add_return(info, r);
	apis->add_return(info, ret3);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// TimelineRuntime.Timeline PlayAction(Boolean, UnityEngine.GameObject, Assets.Scripts.GameLogic.Project8PlayerInstance) declare in Assets.Scripts.GameSystem.UIHeroOp
bool w_otboDo(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otboDo");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<bool>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            // LuaValToCSVal ref with default
    Il2CppObject* p2 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 2, TIp2);
    typedef Il2CppObject* (*FuncToCall)(void*,bool p1, Il2CppObject* p2, Il2CppObject* p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] GetDateTimeFormats(Char) declare in System.DateTime
bool w_otc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otc");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] Split(Char, System.StringSplitOptions) declare in System.String
bool w_otcDi4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otcDi4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendJoin(Char, System.Object[]) declare in System.Text.StringBuilder
bool w_otcVO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otcVO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
            // LuaValToCSVal ref params
    Il2CppArray* p1 = Params<void*>::PackRef(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder AppendJoin(Char, System.String[]) declare in System.Text.StringBuilder
bool w_otcVs(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otcVs");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;        if(lua_args_len > 1 && !converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
             // LuaValToCSVal string params
    Il2CppArray* p1 = Params<void*>::PackString(apis, env, info, TIp1, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, Il2CppArray* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Replace(Char, Char) declare in System.Text.StringBuilder
bool w_otcc(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otcc");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, Il2CppChar p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Replace(Char, Char, Int32, Int32) declare in System.Text.StringBuilder
bool w_otcci4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otcci4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
                
    // LuaValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(apis, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, Il2CppChar p2, int32_t p3, int32_t p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(Char, Int32) declare in System.Text.StringBuilder
bool w_otci4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otci4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] Split(Char, Int32, System.StringSplitOptions) declare in System.String
bool w_otci4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otci4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (lua_args_len > 2 && !converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
         // LuaValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.String[] GetDateTimeFormats(Char, System.IFormatProvider) declare in System.DateTime
bool w_otco(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_otco");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,Il2CppChar p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(SByte) declare in System.Text.StringBuilder
bool w_oti1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int8_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.Framework.AssetService.BaseAsset LoadAsset(Assets.Scripts.Framework.AssetService.AssetType, System.String, Assets.Scripts.Framework.AssetService.LifeType, System.String, Int32, System.Object) declare in Assets.Scripts.Framework.AssetService.AssetService
bool w_oti1si1sDi4DO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti1si1sDi4DO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    int _sv4 = apis->get_arg(info, 4);
    int _sv5 = apis->get_arg(info, 5);
    if (true) {
        if (lua_args_len < 4 || lua_args_len > 6) 
            return false;

        if (!converter::Converter<int8_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv2))
            return false;
        if (!converter::Converter<Il2CppString*>::accept(apis, env, _sv3))
            return false;
        if (lua_args_len > 4 && !converter::Converter<int32_t>::accept(apis, env, _sv4))
            return false;        
    }
        
    // LuaValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(apis, env, _sv0);
            // LuaValToCSVal s
    Il2CppString* p1 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv1);        
    // LuaValToCSVal P any
    int8_t p2 = converter::Converter<int8_t>::toCpp(apis, env, _sv2);
            // LuaValToCSVal s
    Il2CppString* p3 = converter::Converter<Il2CppString*>::toCpp(apis, env, _sv3); // LuaValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 4);
                // LuaValToCSVal ref with default
    Il2CppObject* p5 = OptionalParameter<Il2CppObject*>::GetRefType(apis, env, info, method, wrapData, lua_args_len, 5, TIp5);
    typedef Il2CppObject* (*FuncToCall)(void*,int8_t p1, Il2CppString* p2, int8_t p3, Il2CppString* p4, int32_t p5, Il2CppObject* p6, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Append(Int16) declare in System.Text.StringBuilder
bool w_oti2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int16_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int16_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.Transform ExtGetChild(UnityEngine.Transform, Int32) declare in ExtTransform
bool w_oti4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    if (checkLuaArgument) {
        if (lua_args_len != 1) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Assets.Scripts.GameLogic.Project8ArtField GetArtField(Int32, SceneLevelDefine) declare in Assets.Scripts.GameLogic.Project8Logic
bool w_oti4Di4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4Di4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (true) {
        if (lua_args_len < 1 || lua_args_len > 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (lua_args_len > 1 && !converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
         // LuaValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 1);
            
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, System.Object) declare in System.Text.StringBuilder
bool w_oti4O(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4O");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, System.ReadOnlySpan`1[System.Char]) declare in System.Text.StringBuilder
bool w_oti4S_S_p_i4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4S_S_p_i4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_S_p_i4_* pp1 = DataTransfer::GetPointer<S_S_p_i4_>(apis, env, _sv1);
    S_S_p_i4_ p1 = pp1 ? *pp1 : S_S_p_i4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, struct S_S_p_i4_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, System.Decimal) declare in System.Text.StringBuilder
bool w_oti4S_i4i4i4i4u8_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4S_i4i4i4i4u8_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_i4i4i4i4u8_* pp1 = DataTransfer::GetPointer<S_i4i4i4i4u8_>(apis, env, _sv1);
    S_i4i4i4i4u8_ p1 = pp1 ? *pp1 : S_i4i4i4i4u8_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, struct S_i4i4i4i4u8_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// UnityEngine.RectTransform CreateItem(Int32, UnityEngine.Vector3) declare in Timi.TimiListView
bool w_oti4S_r4r4r4_(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4S_r4r4r4_");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, true))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
             // LuaValToCSVal struct
    S_r4r4r4_* pp1 = DataTransfer::GetPointer<S_r4r4r4_>(apis, env, _sv1);
    S_r4r4r4_ p1 = pp1 ? *pp1 : S_r4r4r4_ {};
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, struct S_r4r4r4_ p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Boolean) declare in System.Text.StringBuilder
bool w_oti4b(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4b");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<bool>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, bool p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Char) declare in System.Text.StringBuilder
bool w_oti4c(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4c");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<Il2CppChar>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppChar p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, SByte) declare in System.Text.StringBuilder
bool w_oti4i1(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i1");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int8_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int8_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Int16) declare in System.Text.StringBuilder
bool w_oti4i2(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i2");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int16_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int16_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// Char[] ToCharArray(Int32, Int32) declare in System.String
bool w_oti4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.IO.FileStream Open(System.IO.FileMode, System.IO.FileAccess, System.IO.FileShare) declare in System.IO.FileInfo
bool w_oti4i4i4(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i4i4");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (checkLuaArgument) {
        if (lua_args_len != 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
                
    // LuaValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(apis, env, _sv2);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, int32_t p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Reflection.MemberInfo[] FindMembers(System.Reflection.MemberTypes, System.Reflection.BindingFlags, System.Reflection.MemberFilter, System.Object) declare in System.Type
bool w_oti4i4oO(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i4oO");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (checkLuaArgument) {
        if (lua_args_len != 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int32_t>::accept(apis, env, _sv1))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv2, TIp2, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(apis, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
            
    // LuaValToCSVal o/O
    Il2CppObject* p3 = LuaValueToCSRef(apis, TIp3, env, _sv3);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int32_t p2, Il2CppObject* p3, Il2CppObject* p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Int64) declare in System.Text.StringBuilder
bool w_oti4i8(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4i8");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!converter::Converter<int64_t>::accept(apis, env, _sv1))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
                
    // LuaValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(apis, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, int64_t p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Text.StringBuilder Insert(Int32, Char[]) declare in System.Text.StringBuilder
bool w_oti4o(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4o");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    if (checkLuaArgument) {
        if (lua_args_len != 2) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
        
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Action`1[System.Int32] AddBind(ResData.ActorAbilitySymmetryType, System.Action`1[System.Int32], Boolean) declare in BindableDict`2[ResData.ActorAbilitySymmetryType,System.Int32]
bool w_oti4oDb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4oDb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    if (true) {
        if (lua_args_len < 2 || lua_args_len > 3) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 2 && !converter::Converter<bool>::accept(apis, env, _sv2))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
         // LuaValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 2);
            
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, bool p3, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
// System.Action`1[System.Int32] AddBind2Target(ResData.ActorAbilitySymmetryType, System.Action`1[System.Int32], System.Object, Boolean) declare in BindableDict`2[ResData.ActorAbilitySymmetryType,System.Int32]
bool w_oti4oODb(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData) {
    // PLog("Running w_oti4oODb");
    AutoValueScope value_scope(apis, env);
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    int lua_args_len = apis->get_args_len(info);
    int _sv0 = apis->get_arg(info, 0);
    int _sv1 = apis->get_arg(info, 1);
    int _sv2 = apis->get_arg(info, 2);
    int _sv3 = apis->get_arg(info, 3);
    if (true) {
        if (lua_args_len < 3 || lua_args_len > 4) 
            return false;

        if (!converter::Converter<int32_t>::accept(apis, env, _sv0))
            return false;
        if (!DataTransfer::IsAssignable(apis, env, _sv1, TIp1, false))
            return false;
        if (lua_args_len > 3 && !converter::Converter<bool>::accept(apis, env, _sv3))
            return false;        
    }
        
    // LuaValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(apis, env, _sv0);
            
    // LuaValToCSVal o/O
    Il2CppObject* p1 = LuaValueToCSRef(apis, TIp1, env, _sv1);
            
    // LuaValToCSVal o/O
    Il2CppObject* p2 = LuaValueToCSRef(apis, TIp2, env, _sv2);
         // LuaValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(apis, env, info, method, wrapData, lua_args_len, 3);
            
    typedef Il2CppObject* (*FuncToCall)(void*,int32_t p1, Il2CppObject* p2, Il2CppObject* p3, bool p4, const void* method);
    Il2CppObject* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);
	int r = CSRefToLuaValue(apis, env, TIret, ret);
	apis->add_return(info, r);
    value_scope.reserve = apis->get_return_num(info);
    return true;
}
}

