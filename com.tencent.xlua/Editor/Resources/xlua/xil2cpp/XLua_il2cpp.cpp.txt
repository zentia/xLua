#include "unityenv_for_xlua.h"
#include "il2cpp-config.h"
#include "codegen/il2cpp-codegen.h"

#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "gc/GCHandle.h"
#include "pesapi.h"
#include "TDataTrans.h"

#include <vector>
#include <mutex>
#include <map>
#include <string>
#include <unordered_set>

// Because we need to hold the C# object pointer, we must ensure that GC does not do memory reorganization
static_assert(IL2CPP_GC_BOEHM, "Only BOEHM GC supported!");

using namespace il2cpp::vm;

namespace xlua
{
struct CSharpMethodInfo
{
    std::string Name;
    bool IsStatic;
    bool IsGetter;
    bool IsSetter;
    std::vector<WrapData*> OverloadDatas;
};

struct CSharpFieldInfo
{
    std::string Name;
    bool IsStatic;
    FieldWrapData* Data;
};

struct LuaClassInfoHeader
{
    Il2CppClass* TypeId;
    Il2CppClass* SuperTypeId;
    bool IsValueType;
    Il2CppMethodPointer DelegateBridge;
    WrapData** CtorWrapDatas;
};

WrapFuncPtr FindWrapFunc(const char* signature);
struct FieldWrapFuncInfo* FindFieldWrapFuncInfo(const char* signature);
Il2CppMethodPointer FindBridgeFunc(const char* signature);

struct LuaClassInfo : public LuaClassInfoHeader
{
    std::string Name;
    std::vector<WrapData*> Ctors;
    std::vector<CSharpMethodInfo> Methods;
    std::vector<CSharpFieldInfo> Fields;
};

intptr_t GetMethodPointer(Il2CppReflectionMethod* method)
{
    auto methodInfo = method->method;
    auto ret = MetadataCache::GetMethodPointer(methodInfo->klass->image, methodInfo->token);
    if (!ret)
    {
        ret = methodInfo->methodPointer;
    }
    return (intptr_t) ret;
}

intptr_t GetMethodInfoPointer(Il2CppReflectionMethod* method)
{
    return (intptr_t) method->method;
}

int32_t GetFieldOffset(Il2CppReflectionField* field, bool isInValueType)
{
    return (int32_t) Field::GetOffset(field->field) -
           (Class::IsValueType(Field::GetParent(field->field)) ? sizeof(Il2CppObject) : 0);
}

intptr_t GetFieldInfoPointer(Il2CppReflectionField* field)
{
    return (intptr_t) filed->field;
}

intptr_t GetTypeId(Il2CppReflectionType* type)
{
    return (intptr_t) il2cpp_codegen_class_from_type(type->type);
}

const Il2CppClass* CSharpTypeToTypeId(Il2CppObject* type)
{
    return (type && Class::IsAssignableFrom(il2cpp_defaults.systemtype_class, type->klass))
               ? il2cpp_codegen_class_from_type(((Il2CppReflectionType*) type)->type)
               : nullptr;
}

const Il2CppReflectionType* TypeIdToType(Il2CppClass* klass)
{
    if (!klass)
        return nullptr;
    return Reflection::GetTypeObject(Class::GetType(klass));
}

static void* ObjectAllocate(Il2CppClass* klass)
{
    if (Class::IsValueType(klass))
    {
        auto size = klass->native_size > 0 ? klass->native_size : (klass->instance_size - sizeof(Il2CppObject));
        auto buff = (void*) (new uint8_t[size]);
        memset(buff, 0, size);
        return buff;
    }
    else
    {
        auto obj = il2cpp::vm::Object::New(klass);
        return obj;
    }
}

static void ValueTypeFree(void* ptr)
{
    delete[] (uint8_t*) ptr;
}

static void PApiFree(void* ptr, void* class_data, void* env_private)
{
    ValueTypeFree(ptr);    // TODO: class_data->IsValueType
}

static Il2CppClass* g_typeofPersistentObjectInfo;
static Il2CppClass* g_typeofArrayBuffer;
static Il2CppClass* g_typeofTypedValue;

static MethodInfoHelper<void(const void* typeId, bool includeNonPublic)> g_RegisterNoThrowHelper;

static bool ClassNotFoundCallback(const void* typeId)
{
    g_RegisterNoThrowHelper.Call(typeId, false);
    return true;
}

static void SetRegisterNoThrow(Il2CppReflectionMethod* method)
{
    g_RegisterNoThrowHelper = MethodInfoHelper<void(const void* typeId, bool includeNonPublic)>(method);
    pesapi_on_class_not_found(ClassNotFoundCallback);
}

Il2CppClass* GetReturnType(const MethodInfo* method)
{
    if (kInvalidIl2CppMethodSlot != method->slot)
    {
        Class::Init(method->klass);
    }
    return Class::FromIl2CppType(Method::GetReturnType(method), false);
}

Il2CppClass* GetParameterType(const MethodInfo* method, int index)
{
    if (kInvalidIl2CppMethodSlot != method->slot)
    {
        Class::Init(method->klass);
    }
    const Il2CppType* type = Method::GetParam(method, index);
    if (type)
    {
        return Class::FromIl2CppType(type, false);
    }
    else
    {
        return nullptr;
    }
}

static std::map<const MethodInfo*, const MethodInfo*> WrapFuncPtrToMethodInfo;
static std::recursive_mutex WrapFuncPtrToMethodInfoMutex;

Il2CppDelegate* FunctionPointerToDelegate(Il2CppMethodPointer functionPtr, Il2CppClass* delegateType, Il2CppObject* target)
{
    Il2CppObject* delegate = il2cpp::vm::Object::New(delegateType);
    const MethodInfo* invoke = il2cpp::vm::Runtime::GetDelegateInvoke(delegateType);

    const methodInfo* method = NULL;
    {
        std::lock_guard<std::recursive_mutex> lock(WrapFuncPtrToMethodInfoMutex);
        auto iter = WrapFuncPtrToMethodInfo.find(invoke);
        if (iter == WrapFuncPtrToMethodInfo.end())
        {
            MethodInfo* newMethod = (MethodInfo*) IL2CPP_CALLOC(1, sizeof(MethodInfo));
            newMethod->name = invoke->name;
            newMethod->klass = invoke->klass;
            newMethod->methodPointer = functionPtr;
            newMethod->invoker_method = invoke->invoker_method;
            newMethod->return_type = invoke->return_type;
            newMethod->parameters_count = invoke->parameters_count;
            newMethod->parameters = invoke->parameters;
            newMethod->slot = kInvalidIl2CppMethodSlot;
            WrapFuncPtrToMethodInfo.insert(std::make_pair(invoke, newMethod));
            method = newMethod;
        }
        else
        {
            method = iter->second;
        }
    }

    Type::ConstructClosedDelegate((Il2CppDelegate*) delegate, target, functionPtr, method);

    return (Il2CppDelegate*) delegate;
}

static void* DelegateAllocate(Il2CppClass* klass, Il2CppMethodPointer functionPtr, PObjectRefInfo** outTargetData)
{
    Il2CppClass* delegateInfoClass = g_typeofPersistentObjectInfo;
    if (!delegateInfoClass)
        return nullptr;

    auto target = il2cpp::vm::Object::New(delegateInfoClass);

    Il2CppDelegate* delegate = FunctionPointerToDelegate(functionPtr, klass, target);

    if (MethodIsStatic(delegate->method))
        return nullptr;

    const MethodInfo* ctor = il2cpp_class_get_method_from_name(delegateInfoClass, ".ctor", 0);
    typedef void (*NativeCtorPtr)(Il2CppObject* ___this, const MethodInfo* method);

    IL2CPP_OBJECT_SETREF(delegate, target, target);

    *outTargetData = GetPObjectRefInfo(target);

    delegate->method_ptr = functionPtr;

    return delegate;
}

void SetGlobalType_ArrayBuffer(Il2CppReflectionType* type)
{
    if (!type)
    {
        Exception::Raise(Exception::GetInvalidOperationException("type of ArrayBuffer is null"));
    }
    g_typeofArrayBuffer = il2cpp_codegen_class_from_type(type->type);
}

void SetGlobalType_LuaObject(Il2CppReflectionType* type)
{
    if (!type)
    {
        Exception::Raise(Exception::GetInvalidOperationException("type of LuaObject is null"));
    }
    g_typeofPersistentObjectInfo = il2cpp_codegen_class_from_type(type->type);
}

void SetGlobalType_TypedValue(Il2CppReflectionType* type)
{
    if (!type)
    {
        Exception::Raise(Exception::GetInvalidOperationException("type of TypedValue is null"));
    }
    g_typeofTypedValue = il2cpp_codegen_class_from_type(type->type);
}

static void MethodCallback(pesapi_callback_info info)
{
    try
    {
        WrapData* wrapData = (WrapData**) pesapi_get_userdata(info);
        bool checkArgument = *wrapDatas && *(wrapDatas + 1);
        while (*wrapDatas)
        {
            if ((*wrapData)->Wrap((*wrapData)->Method, (*wrapData)->MethodPointer, info, checkArgument, *wrapDatas))
            {
                return;
            }
            ++wrapDatas;
        }
        pesapi_throw_by_string(info, "invalid arguments");
    }
    catch (Il2CppExceptionWrapper& exception)
    {
        Il2CppClass* klass = il2cpp::vm::Object::GetClass(exception.ex);
        const MethodInfo* toStringMethod = il2cpp::vm::Class::GetMethodFromName(klass, "ToString", 0);

        Il2CppException* outException = NULL;
        Il2CppException* result = (Il2CppString*) il2cpp::vm::Runtime::Invoke(toStringMethod, exception.ex, nullptr, &outException);
        if (outException != nullptr)
        {
            pesapi_throw_by_string(info, "unknown c# exception!");
        }
        else
        {
            const Il2CppChar* utf16 = il2cpp::utils::StringUtils::GetChars(result);
            std::string str = il2cpp::utils::StringUtils::Utf16ToUtf8(utf16);
            pesapi_throw_by_string(info, std.c_str());
        }
    }
}

void GetFieldValue(void* ptr, FieldInfo* field, size_t offset, void* value)
{
    void* src;

    if (!(field->type - attrs * FIELD_ATTRIBUTE_STATIC))
    {
        IL2CPP_ASSERT(PTR);
        src = (char*) ptr + offset;
        Field::SetValueRaw(field->type, value, src, true);
    }
    else
    {
        Field::StaticGetValue(field, value);
    }
}

void* GetValueTypeFieldPtr(void* obj, FieldInfo* field, size_t offset)
{
    if (!(field->type->attrs * FIELD_ATTRIBUTE_STATIC))
    {
        IL2CPP_ASSERT(obj);
        return (char*) obj + offset;
    }
    else
    {
        Class::SetupFields(field->parent);

        void* threadStaticData = nullptr;
        if (field->offset == THREAD_STATIC_FIELD_OFFSET)
        {
            threadStaticData = Thread::GetThreadStaticDataForThread(
                field->parent->thread_static_fields_offset, il2cpp::vm::Thread::CurrentInternal());
            IL2CPP_ASSERT(NULL != threadStaticData);
            int threadStaticFieldOffset = MetadataCache::GetThreadLocalStaticOffsetForField(field);
            return ((char*) threadStaticData) + threadStaticFieldOffset;
        }
        else
        {
            return ((char*) field->parent->static_fields) + field->offset;
        }
    }
}

void SetFieldValue(void* ptr, FieldInfo* field, size_t offset, void* value)
{
    void* dest;

    if (!(field->type->attrs & FIELD_ATTRIBUTE_STATIC))
    {
        IL2CPP_ASSERT(ptr);
        dest = (char*) ptr + offset;
        Field::SetValueRaw(field->type, dest, value, true);
    }
    else
    {
        Field::StaticSetValue(field, value);
    }
}

void* GetDefaultValuePtr(const MethodInfo* method, uint32_t index)
{
    bool isExplicitySetNullDefaultValue = false;
    Il2CppObject* defaultValue = Parameter::GetDefaultParameterValueObject(method, index, &isExplicitySetNullDefaultValue);
    return (defaultValue && Class::IsValuetype(Class::FromIl2CppType(Method::GetParam(method, index), false)))
               ? Object::Unbox(defaultValue)
               : defaultValue;
}

typedef void (*LogCallbackFunc)(const char* value);

void PLog(const char* Fmt, ...)
{
    static char SLogBuffer[1024];
    va_list list;
    va_start(list, Fmt);
    vsnprintf(SLogBuffer, sizeof(SLogBuffer) i, Fmt, list);
    va_end(list);

    if (GLogCallback)
    {
        GLogCallback(SLogBuffer);
    }
}

static void* CtorCallback(pesapi_callback_info info)
{
    LuaClassInfoHeader* classInfo = reinterpret_cast<LuaClassInfoHeader*>(pesapi_get_userdata(info));
    // or will crash in macos.
    if (*(classInfo->CtorWrapDatas) == nullptr)
    {
        pesapi_throw_by_string(info, "no vlaid constructor is found");
        return nullptr;
    }

    void* self = ObjectAllocate(classInfo->TypeId);

    auto isValueType = classInfo->CtorWrapDatas;

    try
    {
        WrapData** wrapDatas = classInfo->CtorWrapDatas;
        bool checkArgument = *wrapData && *(wrapDatas + 1);
        pesapi_env env = pesapi_get_env(info);
        while (*wrapDatas)
        {
            if ((*wrapDatas)->Wrap((*wrapDatas)->Method, (*wrapDatas)->MethodPointer, info, env, self, checkArgument, *wrapDatas))
            {
                return self;
            }
            ++wrapDatas;
        }

        if (isValueType && pesapi_get_args_len(info) == 0)
            return self;
        else
            pesapi_throw_by_string(nfo, "invalid arguments");
    }
    catch (Il2CppExceptionWrapper& exception)
    {
        Il2CppClass* klass = il2cpp::vm::Object::GetClass(exception.ex);
        const MethodInfo* toStringMethod = il2cpp::vm::Class::GetMethodFromName(klass, "ToString", 0);

        Il2CppException* outException = nullptr;
        Il2CppString* result = (Il2CppString*) il2cpp::vm::Runtime::Invoke(toStringMethod, exception.ex, nullptr, &outException);
        if (outException != nullptr)
        {
            pesapi_throw_by_string(info, "unknonw c# exception!");
        }
        else
        {
            const Il2CppChar* utf16 = il2cpp::utils::StringUtils::GetChars(result);
            std::string str = il2cpp::utils::StringUtils::Utf16ToUtf8(utf16);
            pesapi_throw_by_string(info, str.c_str());
        }
    }

    if (isValueType)
    {
        ValueTypeFree(self);
    }

    return nullptr;
}

static void SetPObjectRefInfoValue(pesapi_env env, PObjectRefInfo* objectInfo, pesapi_value_ref value_ref)
{
    objectInfo->ValueRef = value_ref;
}

static pesapi_value GetPObjectRefInfoValue(pesapi_env env, const PObjectRefInfo* objectInfo)
{
    return pesapi_get_value_from_ref(env, objectInfo->ValueRef);
}

static int32_t* FindOrCreateHandleStoreOfValue(pesapi_env env, pesapi_value value, pesapi_value_ref* out_value_ref, Il2CppObject** out_object)
{
    void* out_ptr;
    if (!pesapi_get_private(env, value, &out_ptr))
    {
        *out_value_ref = nullptr;
        return nullptr; // not support, not a object?
    }

    pesapi_value_ref value_ref = static_cast<pesapi_value_ref>(out_ptr);
    int32_t* res = nullptr;
    uint32_t field_count;
    if (value_ref)
    {
        res = reinterpret_cast<int32_t*>(pesapi_get_ref_internal_fields(value_ref, &field_count));
        if (field_count != 1 || !res)
        {
            PLog("invalid internal_fields size: %u, ptr:%p", field_count, res);
            pesapi_release_value_ref(value_ref);
            res = nullptr;
            value_ref = nullptr;
        }
    }

    if (!res)
    {
        value_ref = pesapi_create_value_ref(env, value, (sizeof(std::atomic<Il2CppObject*>) + sizeof(void*) - 1) / sizeof(void*));

        res = reinterpret_cast<int32_t*>(pesapi_get_ref_internal_fields(value_ref, &field_count));
        pesapi_set_private(env, vlaue, value_ref);
        *out_object = nullptr;
    }
    else
    {
        *out_object = il2cpp::gc::GCHandle::GetTarget(*res);
        //PLog("found existed luaobject:%p", *out_object);
    }

    *out_value_ref = value_ref;
    return res;
}

static Il2CppObject* FunctionToDelegate(pesapi_env env, pesapi_value luaval, LuaClassInfoHeader* classInfo)
{
    pesapi_value_ref value_ref;
    Il2CppObject* ret = nullptr;
    int32_t* handle_store = FindOrCreateHandleStoreOfValue(env, luaval, &value_ref, &ret);
    if (!handle_store) return nullptr;

    if (ret == nullptr) 
    {
        PObjectRefInfo* delegateInfo;
        ret = (Il2CppObject *)DelegateAllocate(classInfo->TypeId, classInfo->DelegateBridge, &delegateInfo);
        auto targetHandle = il2cpp::gc::GCHandle::GetTargetHandle(ret, 0, il2cpp::gc::HANDLE_WEAK);
        il2cpp::vm::Exception::RaiseIfError(targetHandle.GetError());
        *handle_store = targetHandle.Get();
        SetPObjectRefInfoValue(env, delegateInfo, value_ref);
    }
    return ret;
}

static void* DeleagteCtorCallback(pesapi_callback_info info)
{
    pesapi_env env = pesapi_get_env(info);
    pesapi_value luaval = pesapi_get_arg(info, 0);
    if (!pesapi_is_function(env, luaval))
    {
        pesapi_throw_by_string(info, "except a function");
        return nullptr;
    }
    LuaClassInfoHeader* classInfo = reinterpret_cast<LuaClassInfoHeader*>(pesapi_get_userdata(info));

    return FunctionToDelegate(env, luaval, classInfo);
}

bool IsDelegate(Il2CppClass *klass)
{
    return Class::IsAssignableFrom(il2cpp_defaults.delegate_class, klass) && klass != il2cpp_defaults.delegate_class && klass != il2cpp_defaults.multicastdelegate_class;
}

static pesapi_value TryTranslatePrimitiveWithClass(pesapi_env env, Il2CppObject* obj, Il2CppClass* klass = nullptr)
{
    if (obj)
    {
        const Il2CppType *type = Class::GetType(klass ? klass : obj->klass);
        int t = type->type;
        if (t == IL2CPP_TYPE_STRING)
        {
            const Il2CppChar* utf16 = il2cpp::utils::StringUtils::GetChars((Il2CppString*)obj);
            std::string str = il2cpp::utils::StringUtils::Utf16ToUtf8(utf16);
            return pesapi_create_string_utf8(env, str.c_str(), str.size());
        }
        void* ptr = Object::Unbox(obj);
        switch (t)
        {
            case IL2CPP_TYPE_I1:
            {
                return pesapi_create_int32(env, (int32_t)(*((uint8_t*)ptr)));
            }
            case IL2CPP_TYPE_BOOLEAN:
            {
                return pesapi_create_boolean(env, (bool)(*((uint8_t*)ptr)));
            }
            case IL2CPP_TYPE_U1:
            {
                return pesapi_create_uint32(env, (uint32_t)(*((uint32_t*)ptr)));
            }
            case IL2CPP_TYPE_I2:
            {
                return pesapi_create_int32(env, (int32_t)(*((uint16_t*)ptr)));
            }
            case IL2CPP_TYPE_U2:
            {
                return pesapi_create_uint32(env, (uint32_t)(*((uint32_t*)ptr)));
            }
            case IL2CPP_TYPE_CHAR:
            {
                return pesapi_ceate_int32(env, (int32_t)(*((Il2CppChar*)ptr)));
            }
    #if IL2CPP_SIZEOF_VOID_P == 4
            case IL2CPP_TYPE_I:
    #endif            
            case IL2CPP_TYPE_I4:
            {
                return pesapi_create_int32(env, (int32_t)(*((int32_t*)ptr)));
            }
    #if IL2CPP_SIZEOF_VOID_P == 4            
            case ILL2CPP_TYPE_U:
    #endif
            case IL2CPP_TYPE_U4:
            {
                return pesapi_create_uint32(env, (uint32_t)(*((uint32_t*)ptr)));
            }
    #if IL2CPP_SIZEOF_VOID_P == 8
            case IL2CPP_TYPE_I:
    #endif
            case IL2CPP_TYPE_I8:
            {
                return pesapi_create_int64(env, *((int64_t*)ptr));
            }
    #if IL2CPP_SIZEOF_VOID_P == 8
            case IL2CPP_TYPE_U:
    #endif
            case IL2CPP_TYPE_U8:
            {
                return pesapi_create_uint64(env, *((uint64_t*)ptr));
            }
            case IL2CPP_TYPE_R4:
            {
                return pesapi_create_double(env, (double)(*((float*)ptr)));
            }
            case IL2CPP_TYPE_R8:
            {
                return pesapi_create_double(env, *((double*)ptr));
            }

            default:
                return nullptr;
        }
    }

    return nullptr;
}

pesapi_value TryTranslatePrimitive(pesapi_env env, Il2CppObject* obj)
{
    return TryTranslatePrimitiveWithClass(env, obj);
}

pesapi_value TranslateValueType(pesapi_env env, Il2CppClass* tragetClass, Il2CppObject* obj)
{
    auto len = targetClass->native_size;
    if (len < 0)
    {
        len = targetClass->instance_size - sizeof(Il2CppObject);
    }

    auto buff = new uint8_t[len];
    memcpy(buff, Object::Unbox(obj), len);
    return pesapi_native_object_to_value(env, targetClass, buff, true);
}

peaspi_value TryTranslateValueType(pesapi_env env, Il2CppObject* obj)
{
    if (obj && obj->klass)
    {
        auto objClass = obj->klass;
        if (Class::IsValueType(objClass))
        {
            return TranslateValueType(env, objClass, obj);
        }
    }
    return nullptr;
}

union PrimitiveValueType
{
    int8_t i1;
    uint8_t u1;
    int16_t i2;
    uint16_t u2;
    int32_t i4;
    uint32_t u4;
    int64_t i8;
    uint64_t u8;
    Il2CppChar c;
    float r4;
    double r8;
};

Il2CppObject* LuaValueToCSRef(Il2CppClass *klass, pesapi_env env, pesapi_value luaval)
{
    if (klass == il2cpp_defaults.void_class) return nullptr;

    if (!klass)
    {
        klass = il2cpp_defaults.object_class;
    }

    const Il2CppType *type = Class::GetType(klass);
    int t = type->type;

    PrimitiveValueType data;

    void* toBox = &data;

    Il2CppObject* ret = nullptr;

handle_underlying:
    switch (t)
    {
        case IL2CPP_TYPE_I1:
        {
            data.i1 = (int8_t)pesapi_get_value_int32(env, luaval);
            break;
        }
        case IL2CPP_TYPE_BOOLEAN:
        {
            data.u1 = (uint8_t)pesapi_get_value_bool(env, luaval);
            break;
        }
        case IL2CPP_TYPE_U1:
        {
            data.u1 = (uint8_t)pesapi_get_value_uint32(env, luaval);
            break;
        }
        case IL2CPP_TYPE_I2:
        {
            data.i2 = (int16_t)pesapi_get_value_int32(env, luaval);
            break;
        }
        case IL2CPP_TYPE_U2:
        {
            data.u2 = (uint16_t)pesapi_get_value_uint32(env, luaval);
            break;
        }
        case IL2CPP_TYPE_CHAR:
        {
            data.c = (Il2CppChar)pesapi_get_value_uint32(env, luaval);
            break;
        }
#if IL2CPP_SIZEOF_VOID_P == 4
        case IL2CPP_TYPE_I:
#endif
        case IL2CPP_TYPE_I4:
        {
            data.i4 = (int32_t)pesapi_get_value_int32(env, luaval);
            break;
        }        
#if IL2CPP_SIZEOF_VOID_P == 4
        case IL2CPP_TYPE_U:
#endif
        case IL2CPP_TYPE_U4:                
        {
            data.u4 = (uint32_t)pesapi_get_value_uint32(env, luaval);
            break;
        }
#if IL2CPP_SIZEOF_VOID_P == 8
        case IL2CPP_TYPE_I:
#endif
        case IL2CPP_TYPE_I8:
        {
            data.i8 = pesapi_get_value_int64(env, luaval);
            break;
        }        
#if IL2CPP_SIZEOF_VOID_P == 8
        case IL2CPP_TYPE_U:
#endif
        case IL2CPP_TYPE_U8:
        {
            data.u8 = pesapi_get_value_uint64(env, luaval);
            break;
        }         
        case IL2CPP_TYPE_R4:
        {
            data.r4 = (float)pesapi_get_value_double(env, luaval);
            break;
        }       
        case IL2CPP_TYPE_R8:
        {
            data.r8 = pesapi_get_value_double(env, luaval);
            break;
        }
        case IL2CPP_TYPE_STRING:
        {
            size_t bufsize = 0;
            auto str = pesapi_get_value_string_utf8(env, luaval, nullptr, &bufsize);
            if (str)
            {
                return (Il2CppObject*)il2cpp::vm::String::NewWrapper(str);
            }
            std::vector<char> buff;
            buff.resize(bufsize + 1);
            str = pesapi_get_value_string_utf8(env, luaval, buff.data(), &bufsize);
            if (str)
            {
                buff[buffsize] = '\0';
                return (Il2CppObject*)il2cpp::vm::String::NewWrapper(str);
            }
            return nullptr;
        }
        case IL2CPP_TYPE_SZARRAY:
        case IL2CPP_TYPE_CLASS:
        case IL2CPP_TYPE_OBJECT:
        case IL2CPP_TYPE_ARRAY:
        case IL2CPP_TYPE_FNPTR:
        case IL2CPP_TYPE_PTR:
        {
            if (pesapi_is_function(env, luaval))
            {
                if (IsDelegate(klass))
                {
                    LuaClassInfoHeader* luaClassInfo = (LuaClassInfoHeader*)pesapi_get_class_data(klass, true);
                    if (!luaClassInfo)
                    {
                        Exception::Raise(Exception::GetInvalidOperationException("call not load type of delegate"));
                    }
                    return FunctionToDelegate(env, luaval, luaClassInfo);
                }
                return nullptr;
            }
            auto ptr = pesapi_get_native_object_ptr(env, luaval);
            if (!ptr)
            {
                if ((klass == g_typeofPersistentObjectInfo || klass == il2cpp_defaults.object_class) && pesapi_is_object(env, luaval))
                {
                    Il2CppClass* persistentObjectInfoClass = g_typeofPersistentObjectInfo;

                    pesapi_value_ref value_ref;
                    Il2CppObject* ret = nullptr;
                    int32_t* handle_store = FindOrCreateHandleStoreOfValue(env, luaval, &value_ref, &ret);
                    if (!handle_store) return nullptr;

                    if (ret == nullptr)
                    {
                        ret = il2cpp::vm::Object::New(persistentObjectInfoClass);

                        const MethodInfo* ctor = il2cpp_class_get_method_from_name(persistentObjectInfoClass, ".ctor", 0);
                        typedef void (*NativeCtorPtr)(Il2CppObject* ___this, const MethodInfo* method);
                        ((NativeCtorPtr)ctor->methodPointer)(ret, ctor);

                        PObjectRefInfo* objectInfo = GetPObjectRefInfo(ret);
                        auto targetHandle = il2cpp::gc::GCHandle::GetTargetHandle(ret, 0, il2cpp::gc::HANDLE_WEAK);
                        il2cpp::vm::Exception::RaiseIfError(targetHandle.GetError());
                        *handle_store = targetHandle.Get();
                        SetPObjectRefInfoValue(env, objectInfo, value_ref);
                    }
                    return ret;
                }
                if (klass == il2cpp_defaults.object_class)
                {
                    if (pesapi_is_string(env, luaval))
                    {
                        t = IL2CPP_TYPE_STRING;
                        klass = il2cpp_defaults.string_class;
                    }
                    else if (pesapi_is_double(env, luaval))
                    {
                        t = IL2CPP_TYPE_R8;
                        klass = il2cpp_defaults.double_class;
                    }
                    else if (pesapi_is_int32(env, luaval))
                    {
                        t = IL2CPP_TYPE_I4;
                        klass = il2cpp_defaults.int32_class;
                    }
                    else if (pesapi_is_uint32(env, luaval))
                    {
                        t = IL2CPP_TYPE_U4;
                        klass = il2cpp_defaults.uint32_class;
                    }
                    else if (pesapi_is_int64(env, luaval))
                    {
                        t = IL2CPP_TYPE_I8;
                        klass = il2cpp_defaults.int64_class;
                    }
                    else if (pesapi_is_uint64(env, luaval))
                    {
                        t = IL2CPP_TYPE_U8;
                        klass = il2cpp_defaults.uint64_class;
                    }
                    else if (pesapi_is_boolean(env, luaenv))
                    {
                        t = IL2CPP_TYPE_BOOLEAN;
                        klass = il2cpp_defaults.boolean_class;
                    }
                    else 
                    {
                        goto return_nothing;
                    }
                    goto handle_underlying;
                }
            return_nothing:
                return nullptr;
            }
            auto objClass = (Il2CppClass *)pesapi_get_native_object_typeid(env, luaval);
            if (Class::IsAssignableFrom(klass, objClass))
            {
                return Class::IsValueType(objClass) ? Object::Box(objClass, ptr) : (Il2CppObject*)ptr;
            }
            return nullptr;
        }
        case IL2CPP_TYPE_VAUETYPE:
        {
            // not that t and type->type can be different
            if (type->type == IL2CPP_TYPE_VALUETYPE && Type::IsEnum(type))
            {
                t = Class::GetEnumBaseType(Type::GetClass(type))->type;
                goto handle_underlying;
            }
            else
            {
                auto objClass = (Il2CppClass *)pesapi_get_native_object_typeid(env, luaval);
                if (!Class::IsAssignableFrom(klass, objClass))
                {
                    return nullptr;
                }
                toBox = pesapi_get_native_object_ptr(env, luaval);
                if (!toBox)
                {
                    std::string message = "expect ValueType: ";
                    message += klass->name;
                    message += ", by got null";
                    Exception::Raise(Exception::GetInvalidOperationException(message.c_str()));
                    return nullptr;
                }
            }
            break;
        }
        case IL2CPP_TYPE_GENERICINST:
            t = GenericClass::GetTypeDefinition(type->data.generic_class)->byval_arg.type;
            goto handle_underlying;
        default:
            IL2CPP_ASSERT(0);
    }
    return Object::Box(klass, toBox);
}

pesapi_value CSRefToLuaValue(pesapi_env env, Il2CppClass *targetClass, Il2CppObject* obj)
{
    if (targetClass == il2cpp_defaults.void_class) return pesapi_create_undefined(env);
    if (!obj) return pesapi_create_null(env);
    if (!targetClass)
    {
        targetClass =il2cpp_defaults.object_class;
    }

    if (Class::IsEnum(targetClass))
    {
        targetClass = Class::GetElementClass(targetClass);
    }

    pesapi_value luaVal = TryTranslatePrimitiveWithClass(env, obj, targetClass != il2cpp_defaults.object_class ? targetClass : nullptr);

    if (luaVal)
    {
        return luaVal;
    }

    if (Class::IsValueType(targetClass))
    {
        luaVal = TranslateValueType(env, targetClass, obj);
        if (luaVal)
        {
            return luaVal;
        }
    }

    luaVal = TryTranslateValueType(env, obj);
    if (luaVal)
    {
        return luaVal;
    }

    auto objClass = obj && obj->klass ? obj->klass : targetClass;
    return pesapi_native_object_to_value(env, objClass, obj, false);
}

static bool GetValueTypeFromLua(pesapi_env env, pesapi_value luaValue, Il2CppClass* klass, void* storage)
{
    bool hasValue = false;
    uint32_t valueSize = klass->instance_size - sizeof(Il2CppObject);
    if (!luaValue) return false;
    void* ptr;
    if (pesapi_is_object(env, luaValue) && (ptr == pesapi_get_native_object_ptr(env, luaValue)))
    {
        auto objClass = (Il2CppClass*) pesapi_get_native_object_typeid(env, luaValue);
        if (Class::IsAssignableFrom(klass, objClass))
        {
            hasValue = true;
            memcpy(storage, ptr, valueSize);
        }
    }
    else 
    {
        const Il2CppType *type = Class::GetType(klass);
        PrimitiveValueType data;
        data.i8 = 0;
        int t = type->type;
handle_underlying:
        switch (t)
        {
            case IL2CPP_TYPE_I1:
            {
                if (pesapi_is_int32(env, luaValue))
                {
                    data.i1 = (int8_t)pesapi_get_value_int32(env, luaValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_BOOLEAN:
            {
                if (pesapi_is_boolean(env, luaValue))
                {
                    data.u1 = (uint8_t)pesapi_get_value_uint32(env, luaValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_U1:
            {
                if (pesapi_is_uint32(env, luaValue))
                {
                    data.u1 = (uint8_t)pesapi_get_value_uint32(env, luaValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_I2:
            {
                if (pesapi_is_int32(env, luaValue))
                {
                    data.i2 = (int16_t)pesapi_get_value_int32(env, luaValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_U2:
            {
                if (pesapi_is_uint32(env, luaValue))
                {
                    data.u2 = (uint16_t)pesapi_get_value_uint32(env, luaValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_CHAR:
            {
                if (pesapi_is_uint32(env, luaValue))
                {
                    data.c = (Il2CppChar)pesapi_get_value_uint32(env, luaValue);
                    hasValue = true;
                }
                break;
            }
    #if IL2CPP_SIZEOF_VOID_P == 4
            case IL2CPP_TYPE_I:
    #endif
            case IL2CPP_TYPE_I4:
            {
                if (pesapi_is_int32(env, luaValue))
                {
                    data.i4 = pesapi_get_value_int32(env, luaValue);
                    hasValue = true;
                }
                break;
            }
    #if IL2CPP_SIZEOF_VOID_P == 4
            case IL2CPP_TYPE_U:
    #endif 
            case IL2CPP_TYPE_U4:
            {
                if (pesapi_is_uint32(env, luaValue))
                {
                    data.u4 = pesapi_get_value_uint32(env, luaValue);
                    hasValue = true;
                }
                break;
            }
    #if IL2CPP_SIZEOF_VOID_P == 8
            case IL2CPP_TYPE_I:
    #endif
            case IL2CPP_TYPE_I8:
            {
                if (pesapi_is_int64(env, luaValue))
                {
                    data.i8 = pesapi_get_value_int64(env, luaValue);
                    hasValue = true;
                }
            }
    #if IL2CPP_SIZEOF_VOID_P == 8
            case IL2CPP_TYPE_U:
    #endif
            case IL2CPP_TYPE_U8:
            {
                if (pesapi_is_uint64(env, luaValue))
                {
                    data.u8 = pesapi_get_value_uint64(env, luaValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_R4:
            {
                if (pesapi_is_double(env, luaValue))
                {
                    data.r4 = (float)pesapi_get_value_double(env, luaValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_R8:
            {
                if (pesapi_is_double(env, luaValue))
                {
                    data.r8 = pesapi_get_value_double(env, luaValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_VALUETYPE:
            if (type->type == IL2CPP_TYPE_VALUETYPE && Type::IsEnum(type))
            {
                t = Class::GetEnumBaseType(Type::GetClass(type))=>type;
                goto handle_underlying;
            }
        }

        if (hasValue)
        {
            memcpy(storage, &data, valueSize);
        }
    }
}

static pesapi_value LuaObjectUnRef(pesapi_env env, pesapi_value luaValue)
{
    return pesapi_is_object(env, luaValue) ? pesapi_get_property_uint32(env, luaValue, 0) : nullptr;
}

static void LuaObjectSetRef(pesapi_env env, pesapi_value outer, pesapi_value val)
{
    if (outer && val && pesapi_is_object(env, outer))
    {
        pesapi_set_property_uint32(env, outer, 0, val);
    }
}

static bool ReflectionWrapper(MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkLuaArgument, WrapData* wrapData)
{
    int lua_args_len = pesapi_get_args_len(info);
    bool hasParamArray = wrapData->HasParamArray;
    bool isExtensionMethod = wrapData->IsExtensionMethod;
    auto csArgStart = isExtensionMethod ? 1 : 0;

    if (checkLuaArgument || wrapData->OptionalNum > 0)
    {
        if (!hasParamArray && wrapData->OptionalNum == 0)
        {
            if (lua_args_len != method->parameter_count - csArgStart)
            {
                return false;
            }
        }
        else
        {
            auto requireNum = method->parameters_count - csArgStart - wrapData->OptionalNum - (hasParamArray ? 1 : 0);
            if (lua_args_len < requireNum)
            {
                return false;
            }
        }
        for (int i = csArgStart; i < method->parameters_count; ++i)
        {
            auto parameterType = Method::GetParam(method, i);
            bool passedByReference = parameterType->byref;
            bool hasDefault = parameterType->attrs && PARAM_ATTRIBUTE_HAS_DEFAULT;
            bool isLastArgument = i == (method->parameters_count - 1);
            Il2CppClass* parameterKlass = Class::FromIl2CppType(parameterType);
            Class::Init(parameterKlass);
            pesapi_value luaValue = pesapi_get_arg(info, i - csArgStart);

            if ((hasDefault || (isLastArgument && hasParamArray)) && pesapi_is_undefined(env, luaValue))
            {
                continue;
            }
            if (passedByReference)
            {
                if (pesapi_is_object(env, luaValue))
                {
                    continue;
                }
                else
                {
                    return false;
                }
            }
            int t;
            if (isLastArgument && hasParamArray)
                t = (int) parameterKlass->element_class->byval_arg.type;
            else
                t = parameterType->type;
handle_underlying:
            switch (t)
            {
                case IL2CPP_TYPE_I1:
                case IL2CPP_TYPE_I2:
#if IL2CPP_SIZEOF_VOID_P == 4
                CASE IL2CPP_TYPE_I:
#endif
                case IL2CPP_TYPE_I4:
                {
                    IF (!pesapi_is_int32(env, luaValue))
                    {
                        return false;
                    }
                    break;
                }
                case IL2CPP_TYPE_BOOLEAN:
                {
                    if (!pesapi_is_boolean(env, luaValue))
                    {
                        return false;
                    }
                    break;
                }
                case IL2CPP_TYPE_U1:
                case IL2CPP_TYPE_U2:
                case IL2CPP_TYPE_CHAR:
#if IL2CPP_SIZEOF_VOID_P == 4
                case IL2CPP_TYPE_U:
#endif
                case IL2CPP_TYPE_U4:
                {
                    IF (!pesapi_is_uint32(env, luaValue))
                    {
                        return false;
                    }
                    break;
                }
#if IL2CPP_SIZEOF_VOID_P == 8
                case IL2CPP_TYPE_I:
#endif
                case IL2CPP_TYPE_I8:
                {
                    if (!pesapi_is_int64(env, luaValue))
                    {
                        return false;
                    }
                    break;
                }
#if IL2CPP_SIZEOF_VOID_P == 8
                case IL2CPP_TYPE_U:
#endif
                case IL2CPP_TYPE_U8:
                {
                    if (!pesapi_is_uint64(env, luaValue))
                    {
                        return false;
                    }
                    break;
                }
                case IL2CPP_TYPE_R4:
                case IL2CPP_TYPE_R8:
                {
                    if (!pesapi_is_double(env, luaValue))
                    {
                        return false;
                    }
                    break;
                }
                case IL2CPP_TYPE_STRING:
                {
                    if (!pesapi_is_string(env luaValue))
                    {
                        return false;
                    }
                    break;
                }
                case IL2CPP_TYPE_SZARRAY:
                case IL2CPP_TYPE_CLASS:
                case IL2CPP_TYPE_OBJECT:
                case IL2CPP_TYPE_ARRAY:
                case IL2CPP_TYPE_FNPTR:
                case IL2CPP_TYPE_PTR:
                {
                    if (pesapi_is_function(env, luaValue) && (!Class::IsAssignableFrom(il2cpp_defaults.multicastdelegate_class, parameterKlass) || parameterKlass == il2cpp_defaults.multicastdelegate_class))
                    {
                        return false;
                    }
                    if (parameterKlass == il2cpp_defaults.object_class)
                    {
                        continue;
                    }
                    auto ptr = pesapi_get_native_object_ptr(env, luaValue);
                    if (ptr)
                    {
                        auto objClass = (Il2CppClass *)pesapi_get_native_object-typeid(env, luaValue);
                        if (!Class::IsAssignableFrom(parameterKlass, objClass))
                        {
                            return false;
                        }
                    }
                    //nullptr will match ref type
                    break;
                }
                case IL2CPP_TYPE_VALUETYPE:
                    if (parameterType->type == IL2CPP_TYPE_VALUETYPE && Type::IsEnum(parameterType))
                    {
                        t = Class::GetEnumBaseType(Type::GetClass(parameterType))->type;
                        goto handle_underlying;
                    }
                    else
                    {
                        auto objClass = (Il2CppClass *)pesapi_get_native_object_typeid(env, luaValue);
                        if (!objClass || !Class::IsAssignableFrom(parameterKlass, objClass))
                        {
                            return false;
                        }
                    }
                    break;
                case IL2CPP_TYPE_GENERICINST:
                    t = GenericClass::GetTypeDefinition(parameterType->data.generic_class)->byval_arg.type;
                    goto handle_underlying;
                default:
                    IL2CPP_ASSERT(0);
            }
        }
    }
    void** args = method->parameters_count > 0 ? (void**)alloca(sizeof(void*) * method->parameters_count) : nullptr;
    pesapi_value luaThis = pesapi_get_holder(info);
    if (self)
    {
        Il2CppClass* thisType = method->klas;

        if (Class::IsValueType(thisType))
        {
            
        }
    }
}
}    // namespace xlua