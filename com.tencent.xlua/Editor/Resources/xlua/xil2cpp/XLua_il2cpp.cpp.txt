#include "unityenv_for_xlua.h"
#include "il2cpp-config.h"
#include "codegen/il2cpp-codegen.h"

#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "gc/GCHandle.h"
#include "pesapi.h"
#include "TDataTrans.h"

#include <vector>
#include <mutex>
#include <map>
#include <string>
#include <unordered_set>

// Because we need to hold the C# object pointer, we must ensure that GC does not do memory reorganization
static_assert(IL2CPP_GC_BOEHM, "Only BOEHM GC supported!");

using namespace il2cpp::vm;

namespace xlua
{
struct CSharpMethodInfo
{
    std::string Name;
    bool IsStatic;
    bool IsGetter;
    bool IsSetter;
    std::vector<WrapData*> OverloadDatas;
};    

struct CSharpFieldInfo
{
    std::string Name;
    bool IsStatic;
    FieldWrapData *Data;
};

struct LuaClassInfoHeader
{
    Il2CppClass* TypeId;
    Il2CppClass* SuperTypeId;
    bool IsValueType;
    Il2CppMethodPointer DelegateBridge;
    WrapData** CtorWrapDatas;
};

WrapFuncPtr FindWrapFunc(const char* signature);
struct FieldWrapFuncInfo * FindFieldWrapFuncInfo(const char* signature);
Il2CppMethodPointer FindBridgeFunc(const char* signature);

struct LuaClassInfo : public LuaClassInfoHeader
{
    std::string Name;
    std::vector<WrapData*> Ctors;
    std::vector<CSharpMethodInfo> Methods;
    std::vector<CSharpFieldInfo> Fields;
};

intptr_t GetMethodPointer(Il2CppReflectionMethod* method)
{
    auto methodInfo = method->method;
    auto ret = MetadataCache::GetMethodPointer(methodInfo->klass->image, methodInfo->token);
    if (!ret)
    {
        ret = methodInfo->methodPointer;
    }
    return (intptr_t)ret;
}

intptr_t GetMethodInfoPointer(Il2CppReflectionMethod* method)
{
    return (intptr_t)method->method;
}

int32_t GetFieldOffset(Il2CppReflectionField* field, bool isInValueType)
{
    return (int32_t)Field::GetOffset(field->field) - (Class::IsValueType(Field::GetParent(field->field)) ? sizeof(Il2CppObject) : 0);
}

intptr_t GetFieldInfoPointer(Il2CppReflectionField* field)
{
    return (intptr_t)filed->field;
}

intptr_t GetTypeId(Il2CppReflectionType *type)
{
    return (intptr_t)il2cpp_codegen_class_from_type(type->type);
}

const Il2CppClass* CSharpTypeToTypeId(Il2CppObject *type)
{
    return (type && Class::IsAssignableFrom(il2cpp_defaults.systemtype_class, type->klass)) ? il2cpp_codegen_class_from_type(((Il2CppReflectionType *)type)->type) : nullptr;
}

const Il2CppReflectionType* TypeIdToType(Il2CppClass* klass)
{
    if (!klass) return nullptr;
    return Reflection::GetTypeObject(Class::GetType(klass));
}

static void* ObjectAllocate(Il2CppClass *klass)
{
    if (Class::IsValueType(klass))
    {
        auto size = klass->native_size > 0 ? klass->native_size : (klass->instance_size - sizeof(Il2CppObject));
        auto buff = (void*)(new uint8_t[size]);
        memset(buff, 0, size);
        return buff;
    } else {
        auto obj = il2cpp::vm::Object::New(klass);
        return obj;
    }
}

static void ValueTypeFree(void* ptr)
{
    delete [] (uint8_t*)ptr;
}

static void PApiFree(void* ptr, void* class_data, void* env_private)
{
    ValueTypeFree(ptr); //TODO: class_data->IsValueType
}

static Il2CppClass *g_typeofPersistentObjectInfo;
static Il2CppClass *g_typeofArrayBuffer;
static Il2CppClass *g_typeofTypedValue;

static MethodInfoHelper<void(const void* typeId, bool includeNonPublic)> g_RegisterNoThrowHelper;

static bool ClassNotFoundCallback(const void* typeId)
{
    g_RegisterNoThrowHelper.Call(typeId, false);
    return true;
}

static void SetRegisterNoThrow(Il2CppReflectionMethod* method)
{
    g_RegisterNoThrowHelper = MethodInfoHelper<void(const void* typeId, bool includeNonPublic)>(method);
    pesapi_on_class_not_found(ClassNotFoundCallback);
}

Il2CppClass* GetReturnType(const MethodInfo* method)
{
    if (kInvalidIl2CppMethodSlot != method->slot) {
        Class::Init(method->klass);
    }
    return Class::FromIl2CppType(Method::GetReturnType(method), false);
}

Il2CppClass* GetParameterType(const MethodInfo* method, int index) 
{
    if (kInvalidIl2CppMethodSlot != method->slot)
    {
        Class::Init(method->klass);
    }
    const Il2CppType* type = Method::GetParam(method, index);
    if (type) {
        return Class::FromIl2CppType(type, false);
    } else {
        return nullptr;
    }
}

static std::map<const MethodInfo*, const MethodInfo*> WrapFuncPtrToMethodInfo;
static std::recursive_mutex WrapFuncPtrToMethodInfoMutex;

Il2CppDelegate* FunctionPointerToDelegate(Il2CppMethodPointer functionPtr, Il2CppClass* delegateType, Il2CppObject* target)
{
    Il2CppObject* delegate = il2cpp::vm::Object::New(delegateType);
    const MethodInfo* invoke = il2cpp::vm::Runtime::GetDelegateInvoke(delegateType);

    const methodInfo* method = NULL;
    {
        std::lock_guard<std::recursive_mutex> lock(WrapFuncPtrToMethodInfoMutex);
        auto iter = WrapFuncPtrToMethodInfo.find(invoke);
        if (iter == WrapFuncPtrToMethodInfo.end())
        {
            MethodInfo* newMethod = (MethodInfo*)IL2CPP_CALLOC(1, sizeof(MethodInfo));
            newMethod->name = invoke->name;
            newMethod->klass = invoke->klass;
            newMethod->methodPointer = functionPtr;
            newMethod->invoker_method = invoke->invoker_method;
            newMethod->return_type = invoke->return_type;
            newMethod->parameters_count = invoke->parameters_count;
            newMethod->parameters = invoke->parameters;
            newMethod->slot = kInvalidIl2CppMethodSlot;
            WrapFuncPtrToMethodInfo.insert(std::make_pair(invoke, newMethod));
            method = newMethod;
        }
        else
        {
            method = iter->second;
        }
    }

    Type::ConstructClosedDelegate((Il2CppDelegate*)delegate, target, functionPtr, method);

    return (Il2CppDelegate*)delegate;
}

static void* DelegateAllocate(Il2CppClass *klass, Il2CppMethodPointer functionPtr, PObjectRefInfo** outTargetData)
{
    Il2CppClass *delegateInfoClass = g_typeofPersistentObjectInfo;
    if (!delegateInfoClass) return nullptr;

    auto target = il2cpp::vm::Object::New(delegateInfoClass);

    Il2CppDelegate* delegate = FunctionPointerToDelegate(functionPtr, klass, target);

    if (MethodIsStatic(delegate->method)) return nullptr;

    const MethodInfo* ctor = il2cpp_class_get_method_from_name(delegateInfoClass, ".ctor", 0);
    typedef void (*NativeCtorPtr)(Il2CppObject* ___this, const MethodInfo* method);

    IL2CPP_OBJECT_SETREF(delegate, target, target);

    *outTargetData = GetPObjectRefInfo(target);

    delegate->method_ptr = functionPtr;

    return delegate;
}

void SetGlobalType_ArrayBuffer(Il2CppReflectionType *type)
{
    if (!type)
    {
        Exception::Raise(Exception::GetInvalidOperationException("type of ArrayBuffer is null"));
    }
    g_typeofArrayBuffer = il2cpp_codegen_class_from_type(type->type);
}
}